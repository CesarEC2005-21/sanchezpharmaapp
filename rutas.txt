from flask import Flask, jsonify, request, g, send_file
from werkzeug.utils import secure_filename
import pymysql.cursors
from flask_jwt import JWT, jwt_required
from flask_cors import CORS
import logging
from decimal import Decimal
import random
import string
from datetime import datetime, timedelta
import os
import shutil
import subprocess
import zipfile
import tempfile
import jwt as pyjwt

# Importar Flask-Mail de forma opcional
try:
    from flask_mail import Mail, Message
    MAIL_AVAILABLE = True
except ImportError:
    MAIL_AVAILABLE = False
    logging.warning("Flask-Mail no está instalado. Las funciones de email no estarán disponibles.")

# Importar librerías para generar PDFs
try:
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    from io import BytesIO
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    logging.warning("ReportLab no está instalado. Las funciones de PDF no estarán disponibles.")

# Importar requests para llamadas HTTP a la API de RENIEC
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    logging.warning("Requests no está instalado. La verificación de DNI no estará disponible.")

# ---------------------------------------------------
# CONFIGURACIÓN LOGS
# ---------------------------------------------------
logging.basicConfig(filename='/tmp/jwt_debug.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# ---------------------------------------------------
# CONEXIÓN A SÁNCHEZ PHARMA
# ---------------------------------------------------
def obtenerconexion_sanchezpharma():
    return pymysql.connect(
        host='nxlsxx.mysql.pythonanywhere-services.com',
        user='nxlsxx',
        password='77910396gG',
        database='nxlsxx$PAF',
        cursorclass=pymysql.cursors.DictCursor
    )


# ---------------------------------------------------
# MODELO DE USUARIO
# ---------------------------------------------------
class UserSanchezPharma(object):
    def __init__(self, id, username, password, rol_id=None):
        self.id = id
        self.username = username
        self.password = password
        self.rol_id = rol_id

    def __str__(self):
        return f"User(id='{self.id}', rol_id='{self.rol_id}')"


# ---------------------------------------------------
# AUTENTICACIÓN
# ---------------------------------------------------
def authenticate(username, password):
    logging.info(f"Intentando autenticar usuario Sánchez Pharma: {username}")

    conn = obtenerconexion_sanchezpharma()
    with conn:
        with conn.cursor() as cursor:
            sql = "SELECT id, username, password, rol_id FROM usuarios WHERE username = %s"
            cursor.execute(sql, (username,))
            result = cursor.fetchone()

    if result and result["password"] == password:
        logging.info(f"Autenticado correctamente Sánchez Pharma: {username} (Rol: {result.get('rol_id', 'N/A')})")
        # Devolver un diccionario con toda la info (incluido rol_id)
        return {
            "id": result["id"],
            "username": result["username"],
            "password": result["password"],
            "rol_id": result.get("rol_id")
        }

    logging.warning("Credenciales incorrectas")
    return None


def identity(payload):
    try:
        user_id = payload.get('identity')
        if not user_id:
            logging.error(f"identity: No se encontró 'identity' en payload: {payload}")
            return None
        
        logging.info(f"identity: Validando token para user_id: {user_id}, payload completo: {payload}")

        # PASO 1: Intentar buscar como usuario interno
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                sql = "SELECT id, username, password FROM usuarios WHERE id = %s"
                cursor.execute(sql, (user_id,))
                result = cursor.fetchone()

        if result:
            logging.info(f"identity: Usuario interno encontrado: {result['username']} (ID: {result['id']})")
            user_obj = UserSanchezPharma(result["id"], result["username"], result["password"])
            logging.info(f"identity: Objeto UserSanchezPharma creado: {user_obj}")
            return user_obj
        
        # PASO 2: Si no es usuario interno, intentar buscar como cliente
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                sql = """
                    SELECT id, email, documento, password 
                    FROM clientes 
                    WHERE id = %s AND estado = 'activo'
                """
                cursor.execute(sql, (user_id,))
                cliente = cursor.fetchone()
        
        if cliente:
            # Crear objeto UserSanchezPharma para el cliente
            # Usar email o documento como username
            email = cliente.get("email") if cliente.get("email") else None
            documento = cliente.get("documento") if cliente.get("documento") else None
            username = email or documento or str(cliente["id"])
            password = cliente.get("password") or ""  # La contraseña puede no ser necesaria para validación
            logging.info(f"Cliente encontrado: {username} (ID: {cliente['id']})")
            return UserSanchezPharma(cliente["id"], username, password)
        
        logging.warning(f"identity: No se encontró usuario ni cliente con ID: {user_id}")
        return None
    except KeyError as e:
        logging.error(f"identity: Error de clave en payload: {repr(e)}, payload recibido: {payload}")
        return None
    except Exception as e:
        logging.error(f"identity: Error en identity para payload {payload}: {repr(e)}")
        import traceback
        logging.error(f"identity: Traceback: {traceback.format_exc()}")
        return None


# ---------------------------------------------------
# FLASK + JWT
# ---------------------------------------------------
app = Flask(__name__)
app.debug = True
app.config['SECRET_KEY'] = 'super-secret'
# Configurar Flask-JWT para aceptar "Bearer" en lugar de "JWT"
app.config['JWT_AUTH_HEADER_PREFIX'] = 'Bearer'
# Configurar expiración del token JWT - 30 días (se renueva automáticamente)
app.config['JWT_EXPIRATION_DELTA'] = timedelta(days=30)
# Configurar tamaño máximo de archivo (16MB)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024

# ---------------------------------------------------
# CONFIGURACIÓN FLASK-MAIL
# ---------------------------------------------------
if MAIL_AVAILABLE:
    # Configuración para Gmail
    app.config['MAIL_SERVER'] = 'smtp.gmail.com'
    app.config['MAIL_PORT'] = 587  # Usar 465 si tienes problemas con 587
    app.config['MAIL_USE_TLS'] = True
    app.config['MAIL_USE_SSL'] = False  # Cambiar a True si usas puerto 465
    app.config['MAIL_USERNAME'] = 'uortiznelsonfab@uss.edu.pe'
    app.config['MAIL_PASSWORD'] = 'oduxhbgvwhfjjuey'  # Debe ser contraseña de aplicación de Google
    app.config['MAIL_DEFAULT_SENDER'] = 'uortiznelsonfab@uss.edu.pe'
    app.config['MAIL_MAX_EMAILS'] = None
    app.config['MAIL_ASCII_ATTACHMENTS'] = False
    
    # Configuración adicional para depuración
    app.config['MAIL_DEBUG'] = True
    app.config['MAIL_SUPPRESS_SEND'] = False
    
    try:
        mail = Mail(app)
        logging.info("Flask-Mail configurado correctamente")
    except Exception as e:
        mail = None
        logging.error(f"Error al inicializar Flask-Mail: {repr(e)}")
else:
    mail = None
    logging.warning("Flask-Mail no configurado porque no está disponible")

# ---------------------------------------------------
# CONFIGURACIÓN CORS
# ---------------------------------------------------
CORS(app, resources={
    r"/*": {
        "origins": "*",  # Permite todos los orígenes (para desarrollo)
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "expose_headers": ["Content-Type", "Authorization"],
        "supports_credentials": True
    }
})

jwt = JWT(app, authenticate, identity)

# ---------------------------------------------------
# FUNCIONES PARA GENERAR PDFs Y ENVIAR CORREOS
# ---------------------------------------------------

def generar_pdf_boleta(venta_data, detalle_venta, cliente_data):
    """Genera un PDF de boleta/comprobante de venta"""
    if not PDF_AVAILABLE:
        logging.error("ReportLab no está disponible para generar PDF")
        return None
    
    try:
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=30, leftMargin=30, topMargin=30, bottomMargin=30)
        story = []
        
        # Estilos
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            textColor=colors.HexColor('#2E7D32'),
            spaceAfter=30,
            alignment=TA_CENTER
        )
        
        # Título
        story.append(Paragraph("BOLETA DE VENTA", title_style))
        story.append(Spacer(1, 0.2*inch))
        
        # Información de la empresa
        empresa_style = ParagraphStyle(
            'Empresa',
            parent=styles['Normal'],
            fontSize=12,
            alignment=TA_CENTER
        )
        story.append(Paragraph("<b>SÁNCHEZ PHARMA</b>", empresa_style))
        story.append(Paragraph("Farmacia y Productos Farmacéuticos", styles['Normal']))
        story.append(Spacer(1, 0.3*inch))
        
        # Información del cliente
        cliente_info = [
            ['Cliente:', cliente_data.get('nombre_completo', 'Cliente no registrado')],
            ['Documento:', cliente_data.get('documento', 'N/A')],
            ['Email:', cliente_data.get('email', 'N/A')],
            ['Teléfono:', cliente_data.get('telefono', 'N/A')],
        ]
        
        cliente_table = Table(cliente_info, colWidths=[2*inch, 4*inch])
        cliente_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.grey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('BACKGROUND', (1, 0), (1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(cliente_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Información de la venta
        venta_info = [
            ['Número de Venta:', venta_data.get('numero_venta', f"#{venta_data.get('id', 'N/A')}")],
            ['Fecha:', venta_data.get('fecha_venta', datetime.now().strftime('%d/%m/%Y %H:%M'))],
            ['Tipo de Venta:', 'Envío a Domicilio' if venta_data.get('tipo_venta') == 'envio_domicilio' else 'Recojo en Tienda'],
            ['Método de Pago:', venta_data.get('metodo_pago_nombre', 'N/A')],
        ]
        
        venta_table = Table(venta_info, colWidths=[2*inch, 4*inch])
        venta_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.grey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('BACKGROUND', (1, 0), (1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(venta_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Detalle de productos
        story.append(Paragraph("<b>DETALLE DE PRODUCTOS</b>", styles['Heading2']))
        story.append(Spacer(1, 0.1*inch))
        
        detalle_data = [['Producto', 'Cantidad', 'Precio Unit.', 'Subtotal']]
        for item in detalle_venta:
            detalle_data.append([
                item.get('producto_nombre', 'N/A'),
                str(item.get('cantidad', 0)),
                f"S/. {float(item.get('precio_unitario', 0)):.2f}",
                f"S/. {float(item.get('subtotal', 0)):.2f}"
            ])
        
        detalle_table = Table(detalle_data, colWidths=[3*inch, 1*inch, 1.5*inch, 1.5*inch])
        detalle_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E7D32')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
        ]))
        story.append(detalle_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Totales
        totales_data = [
            ['Subtotal (sin IGV):', f"S/. {float(venta_data.get('subtotal', 0)):.2f}"],
            ['IGV (18%):', f"S/. {float(venta_data.get('impuesto', 0)):.2f}"],
        ]
        
        if venta_data.get('descuento', 0) > 0:
            totales_data.append(['Descuento:', f"-S/. {float(venta_data.get('descuento', 0)):.2f}"])
        
        totales_data.append(['<b>TOTAL:</b>', f"<b>S/. {float(venta_data.get('total', 0)):.2f}</b>"])
        
        totales_table = Table(totales_data, colWidths=[4*inch, 2*inch])
        totales_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, -1), (1, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, -1), (1, -1), 14),
            ('TEXTCOLOR', (0, -1), (1, -1), colors.HexColor('#2E7D32')),
            ('LINEBELOW', (0, -2), (1, -2), 2, colors.black),
            ('TOPPADDING', (0, -1), (1, -1), 12),
        ]))
        story.append(totales_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Pie de página
        story.append(Paragraph("Gracias por su compra", styles['Normal']))
        story.append(Paragraph("SÁNCHEZ PHARMA - Su salud es nuestra prioridad", styles['Normal']))
        
        # Construir PDF
        doc.build(story)
        buffer.seek(0)
        return buffer.getvalue()
    except Exception as e:
        logging.error(f"Error al generar PDF de boleta: {repr(e)}")
        return None


def generar_pdf_confirmacion_entrega(venta_data, envio_data, cliente_data, detalle_venta=None, usuario_entrega=None):
    """Genera un PDF de confirmación de entrega"""
    if not PDF_AVAILABLE:
        logging.error("ReportLab no está disponible para generar PDF")
        return None
    
    try:
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=30, leftMargin=30, topMargin=30, bottomMargin=30)
        story = []
        
        # Estilos
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            textColor=colors.HexColor('#2E7D32'),
            spaceAfter=30,
            alignment=TA_CENTER
        )
        
        # Título
        story.append(Paragraph("CONFIRMACIÓN DE ENTREGA", title_style))
        story.append(Spacer(1, 0.2*inch))
        
        # Información de la empresa
        empresa_style = ParagraphStyle(
            'Empresa',
            parent=styles['Normal'],
            fontSize=12,
            alignment=TA_CENTER
        )
        story.append(Paragraph("<b>SÁNCHEZ PHARMA</b>", empresa_style))
        story.append(Paragraph("Farmacia y Productos Farmacéuticos", styles['Normal']))
        story.append(Spacer(1, 0.3*inch))
        
        # Mensaje de confirmación
        confirmacion_style = ParagraphStyle(
            'Confirmacion',
            parent=styles['Normal'],
            fontSize=14,
            textColor=colors.HexColor('#2E7D32'),
            alignment=TA_CENTER,
            spaceAfter=20
        )
        story.append(Paragraph("<b>¡Su pedido ha sido entregado exitosamente!</b>", confirmacion_style))
        story.append(Spacer(1, 0.3*inch))
        
        # Información del cliente
        cliente_info = [
            ['Cliente:', cliente_data.get('nombre_completo', 'Cliente no registrado')],
            ['Documento:', cliente_data.get('documento', 'N/A')],
            ['Email:', cliente_data.get('email', 'N/A')],
        ]
        
        cliente_table = Table(cliente_info, colWidths=[2*inch, 4*inch])
        cliente_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.grey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('BACKGROUND', (1, 0), (1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(cliente_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Información de la entrega
        entrega_info = [
            ['Número de Venta:', venta_data.get('numero_venta', f"#{venta_data.get('id', 'N/A')}")],
        ]
        
        # Agregar información específica según el tipo de venta
        tipo_venta_actual = venta_data.get('tipo_venta', '')
        if tipo_venta_actual == 'envio_domicilio' and envio_data:
            # Si es envío a domicilio, mostrar información del envío
            entrega_info.append(['Número de Seguimiento:', envio_data.get('numero_seguimiento', 'N/A')])
            entrega_info.append(['Fecha de Entrega:', envio_data.get('fecha_real_entrega', datetime.now().strftime('%d/%m/%Y %H:%M'))])
            entrega_info.append(['Dirección de Entrega:', envio_data.get('direccion_entrega', 'N/A')])
            entrega_info.append(['Destinatario:', envio_data.get('nombre_destinatario', 'N/A')])
        else:
            # Si es recojo en tienda
            entrega_info.append(['Fecha de Entrega:', datetime.now().strftime('%d/%m/%Y %H:%M')])
            entrega_info.append(['Tipo:', 'Recojo en Tienda'])
        
        # Agregar información de quién entregó/atendió según el tipo de venta
        if usuario_entrega:
            tipo_persona = usuario_entrega.get('tipo', 'usuario')
            if tipo_persona == 'repartidor':
                # Si es envío a domicilio, mostrar el repartidor
                entrega_info.append(['Repartidor:', usuario_entrega.get('nombre_completo', 'N/A')])
            else:
                # Si es recojo en tienda, mostrar el usuario que atendió
                entrega_info.append(['Atendido por:', usuario_entrega.get('nombre_completo', 'N/A')])
        
        entrega_table = Table(entrega_info, colWidths=[2*inch, 4*inch])
        entrega_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.grey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('BACKGROUND', (1, 0), (1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(entrega_table)
        story.append(Spacer(1, 0.3*inch))
        
        # Detalle de productos entregados
        if detalle_venta and len(detalle_venta) > 0:
            story.append(Paragraph("<b>PRODUCTOS ENTREGADOS</b>", styles['Heading2']))
            story.append(Spacer(1, 0.1*inch))
            
            productos_data = [['Producto', 'Cantidad', 'Precio Unit.', 'Subtotal']]
            for item in detalle_venta:
                productos_data.append([
                    item.get('producto_nombre', 'N/A'),
                    str(item.get('cantidad', 0)),
                    f"S/. {float(item.get('precio_unitario', 0)):.2f}",
                    f"S/. {float(item.get('subtotal', 0)):.2f}"
                ])
            
            productos_table = Table(productos_data, colWidths=[3*inch, 1*inch, 1.5*inch, 1.5*inch])
            productos_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E7D32')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])
            ]))
            story.append(productos_table)
            story.append(Spacer(1, 0.3*inch))
            
            # Resumen de costos
            story.append(Paragraph("<b>RESUMEN DE COSTOS</b>", styles['Heading2']))
            story.append(Spacer(1, 0.1*inch))
            
            costos_data = [
                ['Subtotal (sin IGV):', f"S/. {float(venta_data.get('subtotal', 0)):.2f}"],
                ['IGV (18%):', f"S/. {float(venta_data.get('impuesto', 0)):.2f}"],
            ]
            
            if venta_data.get('descuento', 0) > 0:
                costos_data.append(['Descuento:', f"-S/. {float(venta_data.get('descuento', 0)):.2f}"])
            
            costos_data.append(['<b>TOTAL PAGADO:</b>', f"<b>S/. {float(venta_data.get('total', 0)):.2f}</b>"])
            
            costos_table = Table(costos_data, colWidths=[4*inch, 2*inch])
            costos_table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
                ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
                ('FONTNAME', (0, -1), (1, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, -1), (1, -1), 14),
                ('TEXTCOLOR', (0, -1), (1, -1), colors.HexColor('#2E7D32')),
                ('LINEBELOW', (0, -2), (1, -2), 2, colors.black),
                ('TOPPADDING', (0, -1), (1, -1), 12),
            ]))
            story.append(costos_table)
            story.append(Spacer(1, 0.3*inch))
        
        # Pie de página
        story.append(Paragraph("Gracias por confiar en nosotros", styles['Normal']))
        story.append(Paragraph("SÁNCHEZ PHARMA - Su salud es nuestra prioridad", styles['Normal']))
        
        # Construir PDF
        doc.build(story)
        buffer.seek(0)
        return buffer.getvalue()
    except Exception as e:
        logging.error(f"Error al generar PDF de confirmación de entrega: {repr(e)}")
        return None


def enviar_correo_con_pdf(destinatario, asunto, cuerpo, pdf_data, nombre_archivo):
    """Envía un correo electrónico con un PDF adjunto"""
    if not MAIL_AVAILABLE or mail is None:
        logging.warning("Flask-Mail no está disponible. No se puede enviar correo.")
        return False
    
    try:
        msg = Message(
            subject=asunto,
            recipients=[destinatario],
            body=cuerpo,
            sender=app.config['MAIL_DEFAULT_SENDER']
        )
        
        if pdf_data:
            msg.attach(nombre_archivo, 'application/pdf', pdf_data)
        
        mail.send(msg)
        logging.info(f"Correo enviado exitosamente a {destinatario}")
        return True
    except Exception as e:
        logging.error(f"Error al enviar correo a {destinatario}: {repr(e)}")
        return False


# Handler personalizado para errores de JWT
@jwt.jwt_error_handler
def jwt_error_handler(error):
    logging.error(f"JWT Error Handler: {type(error).__name__}: {str(error)}")
    logging.error(f"JWT Error Handler: Request path: {request.path}")
    logging.error(f"JWT Error Handler: Authorization header: {request.headers.get('Authorization', 'None')[:50]}...")
    
    if hasattr(error, 'status_code'):
        if error.status_code == 401:
            # Los tokens no expiran, así que este error es solo por token inválido
            return jsonify({"code": 0, "message": "Token inválido. Por favor, inicia sesión nuevamente."}), 401
        return jsonify({"code": 0, "message": f"Error de autenticación: {str(error)}"}), error.status_code
    
    return jsonify({"code": 0, "message": f"Error de autenticación: {str(error)}"}), 401


# Middleware personalizado para procesar tokens manualmente si Flask-JWT falla
@app.before_request
def procesar_token_manual():
    """
    Procesa el token JWT manualmente si Flask-JWT no lo ha procesado.
    Esto es un fallback para asegurar que g.current_identity se establezca correctamente.
    """
    # Solo procesar si no es un endpoint público y Flask-JWT no ha establecido current_identity
    endpoints_libres = ("api_login", "hello", "probar_conexion_sanchezpharma", "registrar_cliente_publico_sanchezpharma", 
                        "login_google_sanchezpharma", "registrar_cliente_google_sanchezpharma",
                        "verificar_documento_sanchezpharma",
                        "enviar_codigo_recuperacion_sanchezpharma", "verificar_codigo_recuperacion_sanchezpharma",
                        "cambiar_password_recuperacion_sanchezpharma")
    
    if request.method == "OPTIONS" or request.endpoint in endpoints_libres:
        return
    
    # Si Flask-JWT ya procesó el token, no hacer nada
    if hasattr(g, 'current_identity') and g.current_identity is not None:
        return
    
    # Intentar procesar el token manualmente
    auth_header = request.headers.get("Authorization")
    if not auth_header:
        return
    
    try:
        # Extraer el token
        token = None
        if auth_header.startswith("Bearer "):
            token = auth_header.replace("Bearer ", "").strip()
        elif auth_header.startswith("JWT "):
            token = auth_header.replace("JWT ", "").strip()
        
        if not token:
            return
        
        # Decodificar el token usando PyJWT directamente
        try:
            # Flask-JWT usa la SECRET_KEY para decodificar
            # Verificar expiración normalmente (los tokens se renuevan automáticamente)
            payload = pyjwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            logging.info(f"procesar_token_manual: Token decodificado correctamente, payload: {payload}")
            
            # Llamar a la función identity para obtener el usuario
            user = identity(payload)
            if user:
                g.current_identity = user
                logging.info(f"procesar_token_manual: Usuario establecido manualmente: {user.id}")
            else:
                logging.warning(f"procesar_token_manual: identity() retornó None para payload: {payload}")
        except pyjwt.ExpiredSignatureError:
            logging.warning(f"procesar_token_manual: Token expirado")
            # El token expiró - la app debería renovarlo automáticamente
            # No hacer nada, dejar que Flask-JWT maneje el error
        except pyjwt.InvalidTokenError as decode_error:
            logging.error(f"procesar_token_manual: Token inválido: {repr(decode_error)}")
            # No hacer nada, dejar que Flask-JWT maneje el error
        except Exception as decode_error:
            logging.error(f"procesar_token_manual: Error al decodificar token: {repr(decode_error)}")
            # No hacer nada, dejar que Flask-JWT maneje el error
    except Exception as e:
        logging.error(f"procesar_token_manual: Error general: {repr(e)}")
        # No hacer nada, dejar que Flask-JWT maneje el error


# ---------------------------------------------------
# TABLA BLACKLIST (crear si no existe)
# ---------------------------------------------------
def crear_tabla_blacklist():
    conn = obtenerconexion_sanchezpharma()
    with conn:
        with conn.cursor() as cursor:
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS jwt_blacklist (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    token VARCHAR(500),
                    fecha DATETIME DEFAULT NOW()
                )
            """)
        conn.commit()

crear_tabla_blacklist()


# ---------------------------------------------------
# TABLA CÓDIGOS DE RECUPERACIÓN (crear si no existe)
# ---------------------------------------------------
def crear_tabla_codigos_recuperacion():
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                # Verificar si la tabla existe
                cursor.execute("""
                    SELECT COUNT(*) as count 
                    FROM information_schema.tables 
                    WHERE table_schema = 'nxlsxx$PAF' 
                    AND table_name = 'codigos_recuperacion'
                """)
                tabla_existe = cursor.fetchone()['count'] > 0
                
                if not tabla_existe:
                    # Crear tabla nueva SIN restricciones de clave foránea
                    cursor.execute("""
                        CREATE TABLE codigos_recuperacion (
                            id_codigo INT AUTO_INCREMENT PRIMARY KEY,
                            email VARCHAR(255) NOT NULL,
                            codigo VARCHAR(6) NOT NULL,
                            fecha_creacion DATETIME NOT NULL,
                            fecha_expiracion DATETIME NOT NULL,
                            usado BOOLEAN DEFAULT FALSE,
                            fecha_uso DATETIME NULL,
                            INDEX idx_email (email),
                            INDEX idx_codigo (codigo)
                        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                    """)
                    logging.info("Tabla codigos_recuperacion creada correctamente")
                else:
                    # La tabla existe - verificar si tiene la restricción incorrecta
                    try:
                        cursor.execute("""
                            SELECT CONSTRAINT_NAME
                            FROM information_schema.KEY_COLUMN_USAGE
                            WHERE TABLE_SCHEMA = 'nxlsxx$PAF'
                            AND TABLE_NAME = 'codigos_recuperacion'
                            AND REFERENCED_TABLE_NAME = 'usuarios'
                        """)
                        restriccion = cursor.fetchone()
                        
                        if restriccion:
                            # Eliminar la restricción incorrecta
                            constraint_name = restriccion['CONSTRAINT_NAME']
                            cursor.execute(f"""
                                ALTER TABLE codigos_recuperacion 
                                DROP FOREIGN KEY {constraint_name}
                            """)
                            logging.info(f"Restricción incorrecta {constraint_name} eliminada")
                    except Exception as e:
                        logging.warning(f"No se pudo verificar/eliminar restricción: {e}")
            
            conn.commit()
            logging.info("Tabla codigos_recuperacion lista")
    except Exception as e:
        logging.error(f"Error al crear/verificar tabla codigos_recuperacion: {repr(e)}")

crear_tabla_codigos_recuperacion()


# ---------------------------------------------------
# VERIFICAR Y AGREGAR COLUMNAS PARA SEGUIMIENTO EN TIEMPO REAL
# ---------------------------------------------------
def verificar_columnas_seguimiento_envios():
    """
    Verifica y agrega las columnas necesarias para el seguimiento en tiempo real
    de los repartidores en la tabla envios.
    """
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existen las columnas de coordenadas del repartidor
                cursor.execute("""
                    SELECT COLUMN_NAME 
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_SCHEMA = 'nxlsxx$PAF' 
                    AND TABLE_NAME = 'envios' 
                    AND COLUMN_NAME IN ('latitud_repartidor', 'longitud_repartidor', 'fecha_actualizacion')
                """)
                columnas_existentes = [row['COLUMN_NAME'] for row in cursor.fetchall()]
                
                # Agregar latitud_repartidor si no existe
                if 'latitud_repartidor' not in columnas_existentes:
                    try:
                        cursor.execute("""
                            ALTER TABLE envios 
                            ADD COLUMN latitud_repartidor DECIMAL(10, 8) NULL
                        """)
                        logging.info("Columna latitud_repartidor agregada a la tabla envios")
                    except Exception as e:
                        logging.warning(f"No se pudo agregar columna latitud_repartidor: {e}")
                
                # Agregar longitud_repartidor si no existe
                if 'longitud_repartidor' not in columnas_existentes:
                    try:
                        cursor.execute("""
                            ALTER TABLE envios 
                            ADD COLUMN longitud_repartidor DECIMAL(11, 8) NULL
                        """)
                        logging.info("Columna longitud_repartidor agregada a la tabla envios")
                    except Exception as e:
                        logging.warning(f"No se pudo agregar columna longitud_repartidor: {e}")
                
                # Agregar fecha_actualizacion si no existe
                if 'fecha_actualizacion' not in columnas_existentes:
                    try:
                        cursor.execute("""
                            ALTER TABLE envios 
                            ADD COLUMN fecha_actualizacion DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                        """)
                        logging.info("Columna fecha_actualizacion agregada a la tabla envios")
                    except Exception as e:
                        logging.warning(f"No se pudo agregar columna fecha_actualizacion: {e}")
            
            conn.commit()
            logging.info("Verificación de columnas de seguimiento completada")
    except Exception as e:
        logging.error(f"Error al verificar columnas de seguimiento: {repr(e)}")

verificar_columnas_seguimiento_envios()

# ---------------------------------------------------
# VERIFICAR Y CREAR TABLA DE IMÁGENES DE PRODUCTOS
# ---------------------------------------------------
def crear_tabla_imagenes_productos():
    """
    Crea la tabla imagenes_productos si no existe para soportar múltiples imágenes por producto.
    """
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS imagenes_productos (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        producto_id INT NOT NULL,
                        imagen_url VARCHAR(500) NOT NULL,
                        orden INT DEFAULT 0,
                        fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (producto_id) REFERENCES productos(id) ON DELETE CASCADE,
                        INDEX idx_producto (producto_id),
                        INDEX idx_orden (producto_id, orden)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """)
            conn.commit()
            logging.info("Tabla imagenes_productos verificada/creada correctamente")
    except Exception as e:
        logging.error(f"Error al crear tabla imagenes_productos: {repr(e)}")

crear_tabla_imagenes_productos()


# ---------------------------------------------------
# VERIFICACIÓN DE DNI CON API RENIEC (DECOLECTA)
# ---------------------------------------------------
# Token de la API de RENIEC
RENIEC_API_TOKEN = 'sk_11948.1JSj647lps9gpCKSlVpe38nIaby3Lnm4'
RENIEC_API_URL = 'https://api.decolecta.com/'

# Importar requests para llamadas HTTP a la API de RENIEC
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    logging.warning("Requests no está instalado. La verificación de DNI no estará disponible.")

def verificar_dni_reniec(dni):
    """
    Verifica si un DNI existe y es válido usando la API de RENIEC.
    
    Args:
        dni (str): Número de DNI a verificar
        
    Returns:
        dict: {
            'valido': bool,
            'datos': dict con información del DNI si es válido,
            'mensaje': str
        }
    """
    if not REQUESTS_AVAILABLE:
        logging.warning("Requests no está disponible. No se puede verificar DNI.")
        return {
            'valido': False,
            'datos': None,
            'mensaje': 'Servicio de verificación de DNI no disponible'
        }
    
    if not dni or not dni.strip():
        return {
            'valido': False,
            'datos': None,
            'mensaje': 'DNI no proporcionado'
        }
    
    # Limpiar el DNI (solo números)
    dni_limpio = ''.join(filter(str.isdigit, str(dni)))
    
    if len(dni_limpio) != 8:
        return {
            'valido': False,
            'datos': None,
            'mensaje': 'El DNI debe tener 8 dígitos'
        }
    
    try:
        # Hacer la petición a la API de RENIEC
        headers = {
            'Authorization': f'Bearer {RENIEC_API_TOKEN}',
            'Content-Type': 'application/json'
        }
        
        # Usar el endpoint correcto según la documentación oficial
        # GET https://api.decolecta.com/v1/reniec/dni?numero=46027897
        endpoint = f'{RENIEC_API_URL}v1/reniec/dni?numero={dni_limpio}'
        
        respuesta_exitosa = None
        ultimo_error = None
        
        # Configurar requests para NO usar proxy (PythonAnywhere puede tener problemas con proxy)
        # Deshabilitar completamente el uso de proxy
        import os
        # Guardar variables de entorno de proxy originales
        original_proxies = {
            'http_proxy': os.environ.get('http_proxy'),
            'https_proxy': os.environ.get('https_proxy'),
            'HTTP_PROXY': os.environ.get('HTTP_PROXY'),
            'HTTPS_PROXY': os.environ.get('HTTPS_PROXY')
        }
        
        # Eliminar variables de entorno de proxy temporalmente
        for proxy_var in ['http_proxy', 'https_proxy', 'HTTP_PROXY', 'HTTPS_PROXY']:
            if proxy_var in os.environ:
                del os.environ[proxy_var]
        
        proxies = {
            'http': None,
            'https': None
        }
        
        try:
            response = requests.get(endpoint, headers=headers, timeout=10, proxies=proxies, verify=True, allow_redirects=True)
            logging.info(f"GET {endpoint} - Status: {response.status_code}")
            logging.info(f"GET Response Headers: {dict(response.headers)}")
            logging.info(f"GET Response Text: {response.text[:500]}")
            
            # Si el status es 200, la respuesta es exitosa
            if response.status_code == 200:
                try:
                    respuesta_exitosa = response.json()
                    logging.info(f"Respuesta JSON exitosa: {respuesta_exitosa}")
                except Exception as json_error:
                    logging.warning(f"No se pudo parsear JSON: {json_error}, respuesta: {response.text[:200]}")
                    respuesta_exitosa = {'raw': response.text, 'status_code': response.status_code}
            elif response.status_code == 400:
                # Error 400 significa que el DNI no es válido o no existe
                try:
                    error_data = response.json()
                    logging.warning(f"Error 400 de la API: {error_data}")
                    return {
                        'valido': False,
                        'datos': error_data,
                        'mensaje': error_data.get('message', error_data.get('error', 'DNI no encontrado o inválido'))
                    }
                except:
                    return {
                        'valido': False,
                        'datos': {'status_code': 400, 'text': response.text[:200]},
                        'mensaje': f'DNI no encontrado. Status: {response.status_code}'
                    }
            elif response.status_code == 401:
                # Error 401: No autorizado (token inválido)
                logging.error(f"Error 401: Token inválido o no autorizado")
                return {
                    'valido': False,
                    'datos': {'status_code': 401, 'text': response.text[:200]},
                    'mensaje': 'Error de autenticación con la API de RENIEC. Verifique el token.'
                }
            elif response.status_code == 403:
                # Error 403: Prohibido
                logging.error(f"Error 403: Acceso prohibido")
                return {
                    'valido': False,
                    'datos': {'status_code': 403, 'text': response.text[:200]},
                    'mensaje': 'Acceso prohibido a la API de RENIEC.'
                }
            elif response.status_code == 404:
                # Error 404: Endpoint no encontrado
                logging.error(f"Error 404: Endpoint no encontrado")
                return {
                    'valido': False,
                    'datos': {'status_code': 404, 'text': response.text[:200]},
                    'mensaje': 'Endpoint de la API no encontrado. Verifique la URL.'
                }
            elif response.status_code >= 500:
                # Error del servidor
                logging.error(f"Error del servidor: {response.status_code}")
                return {
                    'valido': False,
                    'datos': {'status_code': response.status_code, 'text': response.text[:200]},
                    'mensaje': f'Error del servidor de la API. Status: {response.status_code}'
                }
            else:
                # Otros códigos de error
                logging.warning(f"Status code no exitoso: {response.status_code}, respuesta: {response.text[:200]}")
                ultimo_error = f"Status code: {response.status_code}, Response: {response.text[:200]}"
                respuesta_exitosa = {'status_code': response.status_code, 'text': response.text[:500], 'headers': dict(response.headers)}
        except requests.exceptions.Timeout:
            ultimo_error = "Timeout: La petición tardó más de 10 segundos"
            logging.error(f"Timeout al hacer petición GET a {endpoint}")
            raise  # Re-lanzar para que se maneje en el bloque except externo
        except requests.exceptions.ConnectionError as e:
            ultimo_error = f"Error de conexión: {str(e)}"
            logging.error(f"Error de conexión al hacer petición GET a {endpoint}: {e}")
            raise  # Re-lanzar para que se maneje en el bloque except externo
        except Exception as e:
            ultimo_error = f"Error: {str(e)}"
            logging.error(f"Error al hacer petición GET a {endpoint}: {e}")
            # No re-lanzar aquí, continuar para devolver información útil
        finally:
            # Restaurar variables de entorno de proxy originales
            for proxy_var, value in original_proxies.items():
                if value is not None:
                    os.environ[proxy_var] = value
                elif proxy_var in os.environ:
                    # Si la variable no existía originalmente, eliminarla si fue creada
                    del os.environ[proxy_var]
        
        if respuesta_exitosa:
            # Log completo de la respuesta para debugging
            logging.info(f"Respuesta completa de la API para DNI {dni_limpio}: {respuesta_exitosa}")
            
            # Verificar la estructura de la respuesta según la documentación
            # La API devuelve: first_name, first_last_name, second_last_name, full_name, document_number
            if isinstance(respuesta_exitosa, dict):
                # Verificar si tiene los campos de la respuesta de RENIEC
                if ('first_name' in respuesta_exitosa or 
                    'first_last_name' in respuesta_exitosa or 
                    'second_last_name' in respuesta_exitosa or
                    'full_name' in respuesta_exitosa or
                    'document_number' in respuesta_exitosa):
                    # Si tiene alguno de estos campos, el DNI es válido
                    return {
                        'valido': True,
                        'datos': respuesta_exitosa,
                        'mensaje': 'DNI verificado correctamente'
                    }
                # Verificar si hay error explícito
                elif respuesta_exitosa.get('error') or respuesta_exitosa.get('mensaje') or respuesta_exitosa.get('message'):
                    error_msg = respuesta_exitosa.get('mensaje') or respuesta_exitosa.get('message') or respuesta_exitosa.get('error', 'DNI no encontrado')
                    return {
                        'valido': False,
                        'datos': respuesta_exitosa,
                        'mensaje': error_msg
                    }
                # Si tiene 'raw' pero no otros campos, verificar el contenido
                elif 'raw' in respuesta_exitosa:
                    raw_text = respuesta_exitosa.get('raw', '').lower()
                    # Si el texto contiene información del DNI, considerarlo válido
                    if dni_limpio in raw_text or 'nombre' in raw_text or 'apellido' in raw_text:
                        return {
                            'valido': True,
                            'datos': respuesta_exitosa,
                            'mensaje': 'DNI verificado correctamente'
                        }
        
        # Si llegamos aquí, la respuesta no fue exitosa o no tiene el formato esperado
        # Incluir más información en el log y en la respuesta
        logging.warning(f"Respuesta inesperada de la API RENIEC para DNI {dni_limpio}: {respuesta_exitosa}")
        logging.warning(f"Último error capturado: {ultimo_error}")
        
        # Devolver la respuesta completa para debugging
        mensaje_error = 'No se pudo verificar el DNI.'
        if ultimo_error:
            mensaje_error += f' Error: {ultimo_error}'
        elif respuesta_exitosa:
            if isinstance(respuesta_exitosa, dict):
                status = respuesta_exitosa.get('status_code', 'N/A')
                texto = respuesta_exitosa.get('text', '')[:100]
                mensaje_error += f' Status: {status}, Respuesta: {texto}'
            else:
                mensaje_error += f' Respuesta: {str(respuesta_exitosa)[:200]}'
        else:
            mensaje_error += ' No se recibió respuesta de la API.'
        
        return {
            'valido': False,
            'datos': respuesta_exitosa if respuesta_exitosa else None,
            'mensaje': mensaje_error,
            'debug_info': {
                'endpoint_usado': endpoint,
                'ultimo_error': ultimo_error,
                'respuesta_recibida': bool(respuesta_exitosa)
            }
        }
        
    except requests.exceptions.Timeout:
        logging.warning(f"Timeout al verificar DNI {dni_limpio} con API RENIEC - Se permitirá el registro confiando en la verificación del cliente")
        return {
            'valido': False,
            'datos': None,
            'mensaje': 'Tiempo de espera agotado al verificar el DNI. Por favor, intente nuevamente.',
            'error_conexion': True  # Indica que fue un error de conexión, no de validación
        }
    except requests.exceptions.RequestException as e:
        error_str = str(e)
        # Detectar si es un error de conexión (Connection refused, etc.)
        es_error_conexion = any(term in error_str.lower() for term in ['connection refused', 'connection error', 'failed to establish', 'newconnectionerror'])
        logging.warning(f"Error de conexión al verificar DNI {dni_limpio}: {repr(e)} - Se permitirá el registro confiando en la verificación del cliente")
        return {
            'valido': False,
            'datos': None,
            'mensaje': 'Error de conexión con el servicio de verificación. Por favor, intente nuevamente más tarde.',
            'error_conexion': es_error_conexion  # Indica que fue un error de conexión
        }
    except Exception as e:
        logging.error(f"Error inesperado al verificar DNI {dni_limpio}: {repr(e)}")
        return {
            'valido': False,
            'datos': None,
            'mensaje': f'Error al verificar el DNI: {str(e)}'
        }


def token_en_lista_negra(token):
    conn = obtenerconexion_sanchezpharma()
    with conn:
        with conn.cursor() as cursor:
            cursor.execute("SELECT id FROM jwt_blacklist WHERE token = %s", (token,))
            data = cursor.fetchone()
    return data is not None


# ---------------------------------------------------
# MANEJAR CORS PREFLIGHT (OPTIONS)
# ---------------------------------------------------
@app.before_request
def handle_preflight():
    if request.method == "OPTIONS":
        response = jsonify({})
        response.headers.add("Access-Control-Allow-Origin", "*")
        response.headers.add('Access-Control-Allow-Headers', "Content-Type,Authorization")
        response.headers.add('Access-Control-Allow-Methods', "GET,PUT,POST,DELETE,OPTIONS")
        return response

# ---------------------------------------------------
# VERIFICAR TOKEN EN BLACKLIST
# ---------------------------------------------------
@app.before_request
def verificar_token_blacklist():
    # Saltar verificación para peticiones OPTIONS y endpoints libres
    if request.method == "OPTIONS":
        return
    
    endpoints_libres = ("api_login", "hello", "probar_conexion_sanchezpharma", "registrar_cliente_publico_sanchezpharma", 
                        "login_google_sanchezpharma", "registrar_cliente_google_sanchezpharma",
                        "verificar_documento_sanchezpharma",
                        "enviar_codigo_recuperacion_sanchezpharma", "verificar_codigo_recuperacion_sanchezpharma",
                        "cambiar_password_recuperacion_sanchezpharma")
    if request.endpoint in endpoints_libres:
        return

    # Aceptar tanto "Bearer" como "JWT" para compatibilidad
    auth_header = request.headers.get("Authorization")
    if auth_header:
        logging.debug(f"verificar_token_blacklist: Authorization header recibido para {request.endpoint}: {auth_header[:50]}...")
        token = None
        if auth_header.startswith("Bearer "):
            token = auth_header.replace("Bearer ", "")
            logging.debug(f"verificar_token_blacklist: Token extraído (Bearer): {token[:30]}...")
        elif auth_header.startswith("JWT "):
            token = auth_header.replace("JWT ", "")
            logging.debug(f"verificar_token_blacklist: Token extraído (JWT): {token[:30]}...")
        else:
            logging.warning(f"verificar_token_blacklist: Formato de header no reconocido: {auth_header[:50]}...")
        
        if token and token_en_lista_negra(token):
            logging.warning(f"verificar_token_blacklist: Token en blacklist detectado")
            return jsonify({"code": 0, "message": "Token inválido (logout realizado)"}), 401
    else:
        # Solo loggear si no es un endpoint público (para evitar spam de logs)
        if request.endpoint not in endpoints_libres:
            logging.warning(f"verificar_token_blacklist: No se recibió header Authorization para {request.endpoint}")


# ---------------------------------------------------
# RUTAS
# ---------------------------------------------------
@app.route("/")
def hello():
    return "API Sánchez Pharma funcionando"


# ---------------------------------------------------
# LOGIN
# ---------------------------------------------------
@app.route('/api_login', methods=['POST'])
def api_login():
    try:
        data = request.json
        username = data.get("username")
        password = data.get("password")

        if not username or not password:
            return jsonify({"code": 0, "message": "Usuario y contraseña son requeridos"}), 400

        logging.info(f"Intentando autenticar: {username}")

        # ============================================================
        # PASO 1: Intentar autenticar como usuario interno
        # ============================================================
        user = authenticate(username, password)  # Función existente
        
        if user:
            # Es usuario interno
            logging.info(f"Usuario interno autenticado: {username}")
            
            # Crear objeto UserSanchezPharma para el token
            user_obj = UserSanchezPharma(user["id"], user["username"], user["password"])
            token = jwt.jwt_encode_callback(user_obj)
            
            return jsonify({
                "code": 1,
                "message": "Inicio de sesión exitoso",
                "token": token.decode('utf-8') if hasattr(token, 'decode') else token,
                "user_type": "usuario",
                "user": {
                    "id": user["id"], 
                    "username": user["username"],
                    "rol_id": user.get("rol_id")  # ✨ AGREGAR ROL_ID
                }
            })
        
        # ============================================================
        # PASO 2: Si no es usuario interno, intentar como cliente
        # ============================================================
        conn = obtenerconexion_sanchezpharma()
        cliente = None
        
        try:
            with conn:
                with conn.cursor() as cursor:
                    # Verificar si el campo password existe
                    cursor.execute("SHOW COLUMNS FROM clientes LIKE 'password'")
                    password_exists = cursor.fetchone()
                    
                    if not password_exists:
                        # Si no existe el campo password, no se puede autenticar como cliente
                        logging.warning("Campo 'password' no existe en tabla 'clientes'. Ejecuta: ALTER TABLE clientes ADD COLUMN password VARCHAR(255) AFTER email;")
                        cliente = None
                    else:
                        # Buscar cliente por email o documento
                        # OPCIÓN A: Si usas contraseña en texto plano
                        # sql = """
                        #     SELECT id, nombre, email, documento, telefono 
                        #     FROM clientes 
                        #     WHERE (email = %s OR documento = %s) 
                        #     AND password = %s 
                        #     AND estado = 'activo'
                        # """
                        # cursor.execute(sql, (username, username, password))
                        # cliente = cursor.fetchone()
                        
                        # OPCIÓN B: Si usas hash SHA256 (RECOMENDADO) - ACTIVADA
                        sql = """
                            SELECT id, nombre, email, documento, telefono 
                            FROM clientes 
                            WHERE (email = %s OR documento = %s) 
                            AND password = SHA2(%s, 256)
                            AND estado = 'activo'
                        """
                        cursor.execute(sql, (username, username, password))
                        cliente = cursor.fetchone()
        except Exception as e:
            logging.error(f"Error al buscar cliente: {repr(e)}")
            # Si hay error (probablemente campo password no existe), continuar sin cliente
            cliente = None
        
        if cliente:
            # Es cliente - crear token JWT
            logging.info(f"Cliente autenticado: {username} (ID: {cliente['id']})")
            
            # Crear un objeto similar a User para el token JWT
            # El token necesita un objeto con atributos id, username, password
            cliente_user = UserSanchezPharma(
                cliente["id"], 
                cliente["email"] or cliente["documento"] or str(cliente["id"]), 
                password
            )
            
            token = jwt.jwt_encode_callback(cliente_user)
            
            return jsonify({
                "code": 1,
                "message": "Inicio de sesión exitoso",
                "token": token.decode('utf-8') if hasattr(token, 'decode') else token,
                "user_type": "cliente",
                "cliente_id": cliente["id"],
                "user": {
                    "id": cliente["id"], 
                    "username": cliente["email"] or cliente["documento"] or str(cliente["id"])
                }
            })
        
        # Si no es ni usuario ni cliente
        logging.warning(f"Credenciales incorrectas para: {username}")
        return jsonify({"code": 0, "message": "Credenciales incorrectas"}), 401

    except Exception as e:
        logging.error(f"Error en api_login: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)}), 500


# ---------------------------------------------------
# RENOVAR TOKEN (Renovación automática)
# ---------------------------------------------------
@app.route('/api_renovar_token', methods=['POST'])
@jwt_required()
def api_renovar_token():
    """
    Renueva el token JWT actual.
    Solo funciona si el usuario ya está autenticado (tiene un token válido).
    Genera un nuevo token con la misma identidad pero con nueva fecha de expiración.
    """
    try:
        # Obtener el usuario actual del token (ya validado por @jwt_required)
        current_identity = getattr(g, 'current_identity', None)
        
        if not current_identity:
            # Intentar obtener del payload manualmente
            auth_header = request.headers.get("Authorization")
            if auth_header:
                if auth_header.startswith("Bearer "):
                    token = auth_header.replace("Bearer ", "").strip()
                elif auth_header.startswith("JWT "):
                    token = auth_header.replace("JWT ", "").strip()
                else:
                    token = auth_header.strip()
                
                try:
                    payload = pyjwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'], options={"verify_exp": False})
                    current_identity = identity(payload)
                except Exception as e:
                    logging.error(f"Error al decodificar token para renovación: {repr(e)}")
            
            if not current_identity:
                return jsonify({"code": 0, "message": "No se pudo identificar al usuario"}), 401
        
        # Generar nuevo token con la misma identidad
        nuevo_token = jwt.jwt_encode_callback(current_identity)
        
        # Determinar tipo de usuario
        user_type = "usuario"
        user_id = current_identity.id
        
        # Verificar si es cliente
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT id FROM clientes WHERE id = %s AND estado = 'activo'", (user_id,))
                cliente = cursor.fetchone()
                if cliente:
                    user_type = "cliente"
        
        logging.info(f"Token renovado exitosamente para {user_type} ID: {user_id}")
        
        return jsonify({
            "code": 1,
            "message": "Token renovado exitosamente",
            "token": nuevo_token.decode('utf-8') if hasattr(nuevo_token, 'decode') else nuevo_token,
            "user_type": user_type,
            "user_id": user_id
        })
        
    except Exception as e:
        logging.error(f"Error al renovar token: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error al renovar token: {str(e)}"}), 500


# ---------------------------------------------------
# LOGOUT
# ---------------------------------------------------
@app.route('/api_logout', methods=['POST'])
@jwt_required()
def api_logout():
    try:
        auth_header = request.headers.get("Authorization")
        if not auth_header:
            return jsonify({"code": 0, "message": "Token no enviado"}), 400

        # Aceptar tanto "Bearer" como "JWT"
        if auth_header.startswith("Bearer "):
            token = auth_header.replace("Bearer ", "")
        elif auth_header.startswith("JWT "):
            token = auth_header.replace("JWT ", "")
        else:
            return jsonify({"code": 0, "message": "Formato de token inválido"}), 400

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("INSERT INTO jwt_blacklist (token) VALUES (%s)", (token,))
            conn.commit()

        return jsonify({"code": 1, "message": "Sesión cerrada correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# PROBAR CONEXIÓN BD
# ---------------------------------------------------
@app.route('/probar_conexion_sanchezpharma')
def probar_conexion_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn.cursor() as cursor:
            cursor.execute("SELECT COUNT(*) AS total FROM usuarios")
            total = cursor.fetchone()["total"]
        return jsonify({"message": "Conexión exitosa", "total_usuarios": total})
    except Exception as e:
        return jsonify({"message": "Error", "error": str(e)})


# ---------------------------------------------------
# PROBAR VERIFICACIÓN DE DNI CON RENIEC
# ---------------------------------------------------
@app.route('/probar_verificacion_dni_sanchezpharma/<dni>')
@jwt_required()
def probar_verificacion_dni_sanchezpharma(dni):
    """
    Endpoint de prueba para verificar la conexión con la API de RENIEC.
    Solo para administradores.
    """
    try:
        verificacion = verificar_dni_reniec(dni)
        debug_info = {
            "dni_procesado": ''.join(filter(str.isdigit, str(dni))),
            "requests_disponible": REQUESTS_AVAILABLE,
            "api_url": RENIEC_API_URL,
            "token_configurado": bool(RENIEC_API_TOKEN),
            "endpoint_completo": f'{RENIEC_API_URL}v1/reniec/dni?numero={"".join(filter(str.isdigit, str(dni)))}'
        }
        
        # Agregar información de debug si está disponible
        if 'debug_info' in verificacion:
            debug_info.update(verificacion['debug_info'])
        
        return jsonify({
            "code": 1 if verificacion['valido'] else 0,
            "valido": verificacion['valido'],
            "datos": verificacion['datos'],
            "mensaje": verificacion['mensaje'],
            "debug": debug_info
        })
    except Exception as e:
        logging.error(f"Error en probar_verificacion_dni: {repr(e)}")
        return jsonify({
            "code": 0,
            "valido": False,
            "datos": None,
            "mensaje": f"Error: {str(e)}",
            "debug": {
                "requests_disponible": REQUESTS_AVAILABLE,
                "error_tipo": type(e).__name__,
                "api_url": RENIEC_API_URL,
                "token_configurado": bool(RENIEC_API_TOKEN)
            }
        })


# Endpoint de prueba SIN autenticación para debugging (TEMPORAL - ELIMINAR EN PRODUCCIÓN)
@app.route('/test_reniec_directo/<dni>')
def test_reniec_directo(dni):
    """
    Endpoint temporal para probar la conexión directa con la API de RENIEC.
    NO requiere autenticación - SOLO PARA DEBUGGING
    """
    if not REQUESTS_AVAILABLE:
        return jsonify({
            "error": "Requests no disponible",
            "instalar": "pip install requests"
        })
    
    dni_limpio = ''.join(filter(str.isdigit, str(dni)))
    
    if len(dni_limpio) != 8:
        return jsonify({
            "error": "DNI debe tener 8 dígitos",
            "dni_recibido": dni,
            "dni_procesado": dni_limpio
        })
    
    try:
        headers = {
            'Authorization': f'Bearer {RENIEC_API_TOKEN}',
            'Content-Type': 'application/json'
        }
        
        # Usar el endpoint correcto según la documentación
        # GET https://api.decolecta.com/v1/reniec/dni?numero=46027897
        endpoint = f'{RENIEC_API_URL}v1/reniec/dni?numero={dni_limpio}'
        
        resultados = []
        
        try:
            # Configurar requests para NO usar proxy (PythonAnywhere puede tener problemas con proxy)
            import os
            # Guardar y eliminar variables de entorno de proxy
            original_proxies = {
                'http_proxy': os.environ.get('http_proxy'),
                'https_proxy': os.environ.get('https_proxy'),
                'HTTP_PROXY': os.environ.get('HTTP_PROXY'),
                'HTTPS_PROXY': os.environ.get('HTTPS_PROXY')
            }
            for proxy_var in ['http_proxy', 'https_proxy', 'HTTP_PROXY', 'HTTPS_PROXY']:
                if proxy_var in os.environ:
                    del os.environ[proxy_var]
            
            proxies = {
                'http': None,
                'https': None
            }
            response = requests.get(endpoint, headers=headers, timeout=10, proxies=proxies, verify=True, allow_redirects=True)
            resultados.append({
                "metodo": "GET",
                "endpoint": endpoint,
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "texto": response.text[:500],
                "json": None
            })
            try:
                resultados[-1]["json"] = response.json()
            except:
                pass
        except Exception as e:
            resultados.append({
                "metodo": "GET",
                "endpoint": endpoint,
                "error": str(e)
            })
        
        return jsonify({
            "dni": dni_limpio,
            "token": RENIEC_API_TOKEN[:20] + "..." if RENIEC_API_TOKEN else "No configurado",
            "api_url": RENIEC_API_URL,
            "resultados": resultados
        })
        
    except Exception as e:
        return jsonify({
            "error": str(e),
            "tipo": type(e).__name__
        })


# ---------------------------------------------------
# LISTAR USUARIOS
# ---------------------------------------------------
@app.route('/usuarios_sanchezpharma')
@jwt_required()
def usuarios_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM usuarios")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Usuarios listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# ---------------------------------------------------
# OBTENER SOLO REPARTIDORES (rol_id = 4)
# ---------------------------------------------------
@app.route('/repartidores_sanchezpharma')
@jwt_required()
def repartidores_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Solo usuarios con rol_id = 4 (repartidor)
                cursor.execute("""
                    SELECT id, username, email, nombre, apellido, edad, sexo, rol_id 
                    FROM usuarios 
                    WHERE rol_id = 4
                """)
                data = cursor.fetchall()

        logging.info(f"Repartidores encontrados: {len(data)}")
        return jsonify({"code": 1, "data": data, "message": "Repartidores listados correctamente"})

    except Exception as e:
        logging.error(f"Error al listar repartidores: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# ---------------------------------------------------
# LISTAR ROLES
# ---------------------------------------------------
@app.route('/roles_sanchezpharma')
@jwt_required()
def roles_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM roles")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Roles listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# ---------------------------------------------------
# REGISTRAR USUARIO
# ---------------------------------------------------
@app.route('/registrar_usuario_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_usuario_sanchezpharma():
    try:
        data = request.json

        campos = ["username", "email", "password", "nombre", "apellido", "edad", "sexo", "rol_id"]
        if not all(data.get(c) for c in campos):
            return jsonify({"code": 0, "message": "Faltan campos"})

        # Verificar DNI con RENIEC si se proporciona documento
        # Nota: Los usuarios internos pueden no tener documento, pero si lo tienen, intentar verificar (opcional)
        documento = data.get("documento")
        if documento:
            try:
                verificacion_dni = verificar_dni_reniec(documento)
                if verificacion_dni['valido']:
                    logging.info(f"DNI {documento} verificado correctamente con RENIEC para usuario interno")
                else:
                    # No bloquear el registro, solo registrar un warning
                    logging.warning(f"Advertencia: No se pudo verificar DNI {documento} en el servidor: {verificacion_dni['mensaje']}. El registro continúa.")
            except Exception as e:
                # Si hay un error de conexión, no bloquear el registro
                logging.warning(f"Advertencia: No se pudo verificar DNI {documento} en el servidor debido a: {str(e)}. El registro continúa.")

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si el username ya existe
                cursor.execute("SELECT id FROM usuarios WHERE username = %s", (data.get("username"),))
                usuario_con_username = cursor.fetchone()
                
                if usuario_con_username:
                    return jsonify({"code": 0, "message": "El nombre de usuario ya está en uso. Por favor, elija otro."})
                
                # Verificar si el email ya existe en usuarios
                cursor.execute("SELECT id FROM usuarios WHERE email = %s", (data.get("email"),))
                usuario_con_email = cursor.fetchone()
                
                if usuario_con_email:
                    return jsonify({"code": 0, "message": "El correo electrónico ya está en uso. Por favor, use otro correo."})
                
                # Verificar si el email existe en clientes (no debe haber duplicados entre clientes y usuarios)
                cursor.execute("SELECT id FROM clientes WHERE email = %s", (data.get("email"),))
                cliente_con_email = cursor.fetchone()
                
                if cliente_con_email:
                    return jsonify({"code": 0, "message": "El correo electrónico ya está en uso. Por favor, use otro correo."})
                
                cursor.execute("""
                    INSERT INTO usuarios 
                    (username, email, password, nombre, apellido, edad, sexo, rol_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data["username"], data["email"], data["password"],
                    data["nombre"], data["apellido"], data["edad"],
                    data["sexo"], data["rol_id"]
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Usuario registrado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# EDITAR USUARIO
# ---------------------------------------------------
@app.route('/editar_usuario_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_usuario_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID del usuario"})

        campos_requeridos = ["username", "email", "nombre", "apellido", "edad", "sexo", "rol_id"]
        if not all(data.get(c) for c in campos_requeridos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Si se proporciona password, actualizarlo también
                if data.get("password"):
                    cursor.execute("""
                        UPDATE usuarios 
                        SET username = %s, email = %s, password = %s, nombre = %s, 
                            apellido = %s, edad = %s, sexo = %s, rol_id = %s
                        WHERE id = %s
                    """, (
                        data["username"], data["email"], data["password"],
                        data["nombre"], data["apellido"], data["edad"],
                        data["sexo"], data["rol_id"], data["id"]
                    ))
                else:
                    cursor.execute("""
                        UPDATE usuarios 
                        SET username = %s, email = %s, nombre = %s, 
                            apellido = %s, edad = %s, sexo = %s, rol_id = %s
                        WHERE id = %s
                    """, (
                        data["username"], data["email"],
                        data["nombre"], data["apellido"], data["edad"],
                        data["sexo"], data["rol_id"], data["id"]
                    ))
            conn.commit()

        return jsonify({"code": 1, "message": "Usuario actualizado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# ELIMINAR USUARIO
# ---------------------------------------------------
@app.route('/eliminar_usuario_sanchezpharma/<int:usuario_id>', methods=['DELETE'])
@jwt_required()
def eliminar_usuario_sanchezpharma(usuario_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM usuarios WHERE id = %s", (usuario_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Usuario eliminado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# INVENTARIO - PRODUCTOS
# ---------------------------------------------------

# LISTAR PRODUCTOS
@app.route('/productos_sanchezpharma')
@jwt_required()
def productos_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT p.*, c.nombre as categoria_nombre, pr.nombre as proveedor_nombre
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN proveedores pr ON p.proveedor_id = pr.id
                    ORDER BY p.nombre
                """)
                productos = cursor.fetchall()
                
                # Obtener imágenes para cada producto
                data = []
                for producto in productos:
                    producto_id = producto['id']
                    cursor.execute("""
                        SELECT imagen_url FROM imagenes_productos 
                        WHERE producto_id = %s 
                        ORDER BY orden ASC
                    """, (producto_id,))
                    imagenes = cursor.fetchall()
                    producto['imagenes'] = [img['imagen_url'] for img in imagenes] if imagenes else []
                    data.append(producto)

        return jsonify({"code": 1, "data": data, "message": "Productos listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# OBTENER PRODUCTO POR ID
@app.route('/producto_sanchezpharma/<int:producto_id>')
@jwt_required()
def producto_sanchezpharma(producto_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT p.*, c.nombre as categoria_nombre, pr.nombre as proveedor_nombre
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN proveedores pr ON p.proveedor_id = pr.id
                    WHERE p.id = %s
                """, (producto_id,))
                data = cursor.fetchone()
                
                # Obtener imágenes del producto
                if data:
                    cursor.execute("""
                        SELECT imagen_url FROM imagenes_productos 
                        WHERE producto_id = %s 
                        ORDER BY orden ASC
                    """, (producto_id,))
                    imagenes = cursor.fetchall()
                    data['imagenes'] = [img['imagen_url'] for img in imagenes] if imagenes else []

        if data:
            return jsonify({"code": 1, "data": data, "message": "Producto obtenido correctamente"})
        else:
            return jsonify({"code": 0, "data": {}, "message": "Producto no encontrado"}), 404

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# REGISTRAR PRODUCTO
@app.route('/registrar_producto_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_producto_sanchezpharma():
    try:
        data = request.json

        campos = ["codigo", "nombre", "precio_compra", "precio_venta", "stock_actual", "stock_minimo"]
        if not all(data.get(c) for c in campos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existe la columna descuento_porcentaje, si no existe, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM productos LIKE 'descuento_porcentaje'")
                    if not cursor.fetchone():
                        cursor.execute("ALTER TABLE productos ADD COLUMN descuento_porcentaje DECIMAL(5,2) DEFAULT 0.00 AFTER precio_venta")
                        logging.info("Columna descuento_porcentaje agregada a la tabla productos")
                except Exception as e:
                    logging.warning(f"No se pudo verificar/crear columna descuento_porcentaje: {e}")
                
                cursor.execute("""
                    INSERT INTO productos 
                    (codigo, codigo_barras, nombre, descripcion, categoria_id, proveedor_id,
                     precio_compra, precio_venta, descuento_porcentaje, stock_actual, stock_minimo, unidad_medida,
                     fecha_vencimiento, estado, imagen_url)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("codigo"),
                    data.get("codigo_barras"),
                    data.get("nombre"),
                    data.get("descripcion"),
                    data.get("categoria_id"),
                    data.get("proveedor_id"),
                    data.get("precio_compra"),
                    data.get("precio_venta"),
                    data.get("descuento_porcentaje", 0.0),
                    data.get("stock_actual"),
                    data.get("stock_minimo"),
                    data.get("unidad_medida", "unidad"),
                    data.get("fecha_vencimiento"),
                    data.get("estado", "activo"),
                    data.get("imagen_url")
                ))
                producto_id = cursor.lastrowid
                
                # Si se proporcionan múltiples imágenes, guardarlas en la tabla imagenes_productos
                imagenes = data.get("imagenes", [])
                logging.info(f"📸 Registrando producto {producto_id}: recibidas {len(imagenes) if isinstance(imagenes, list) else 0} imágenes")
                logging.info(f"   Datos recibidos - imagen_url: {data.get('imagen_url')}, imagenes: {imagenes}")
                
                if imagenes and isinstance(imagenes, list):
                    for idx, imagen_url in enumerate(imagenes):
                        if imagen_url and imagen_url.strip():
                            logging.info(f"   Guardando imagen {idx + 1}: {imagen_url.strip()}")
                            cursor.execute("""
                                INSERT INTO imagenes_productos (producto_id, imagen_url, orden)
                                VALUES (%s, %s, %s)
                            """, (producto_id, imagen_url.strip(), idx))
                else:
                    logging.warning(f"   No se recibieron imágenes válidas. Tipo: {type(imagenes)}, Valor: {imagenes}")
            conn.commit()

        return jsonify({"code": 1, "message": "Producto registrado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR PRODUCTO
@app.route('/editar_producto_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_producto_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID del producto"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                producto_id = data.get("id")
                # Verificar si existe la columna descuento_porcentaje, si no existe, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM productos LIKE 'descuento_porcentaje'")
                    if not cursor.fetchone():
                        cursor.execute("ALTER TABLE productos ADD COLUMN descuento_porcentaje DECIMAL(5,2) DEFAULT 0.00 AFTER precio_venta")
                        logging.info("Columna descuento_porcentaje agregada a la tabla productos")
                except Exception as e:
                    logging.warning(f"No se pudo verificar/crear columna descuento_porcentaje: {e}")
                
                cursor.execute("""
                    UPDATE productos 
                    SET codigo = %s, codigo_barras = %s, nombre = %s, descripcion = %s,
                        categoria_id = %s, proveedor_id = %s, precio_compra = %s,
                        precio_venta = %s, descuento_porcentaje = %s, stock_actual = %s, stock_minimo = %s,
                        unidad_medida = %s, fecha_vencimiento = %s, estado = %s,
                        imagen_url = %s
                    WHERE id = %s
                """, (
                    data.get("codigo"),
                    data.get("codigo_barras"),
                    data.get("nombre"),
                    data.get("descripcion"),
                    data.get("categoria_id"),
                    data.get("proveedor_id"),
                    data.get("precio_compra"),
                    data.get("precio_venta"),
                    data.get("descuento_porcentaje", 0.0),
                    data.get("stock_actual"),
                    data.get("stock_minimo"),
                    data.get("unidad_medida", "unidad"),
                    data.get("fecha_vencimiento"),
                    data.get("estado", "activo"),
                    data.get("imagen_url"),
                    producto_id
                ))
                
                # Si se proporcionan múltiples imágenes, actualizar la tabla imagenes_productos
                imagenes = data.get("imagenes", [])
                logging.info(f"📸 Editando producto {producto_id}: recibidas {len(imagenes) if isinstance(imagenes, list) else 0} imágenes")
                logging.info(f"   Datos recibidos - imagen_url: {data.get('imagen_url')}, imagenes: {imagenes}")
                
                if imagenes is not None:
                    # Eliminar imágenes existentes
                    cursor.execute("DELETE FROM imagenes_productos WHERE producto_id = %s", (producto_id,))
                    # Insertar nuevas imágenes
                    if isinstance(imagenes, list) and len(imagenes) > 0:
                        for idx, imagen_url in enumerate(imagenes):
                            if imagen_url and imagen_url.strip():
                                logging.info(f"   Guardando imagen {idx + 1}: {imagen_url.strip()}")
                                cursor.execute("""
                                    INSERT INTO imagenes_productos (producto_id, imagen_url, orden)
                                    VALUES (%s, %s, %s)
                                """, (producto_id, imagen_url.strip(), idx))
                    else:
                        logging.warning(f"   No se recibieron imágenes válidas. Tipo: {type(imagenes)}, Valor: {imagenes}")
            conn.commit()

        return jsonify({"code": 1, "message": "Producto actualizado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ELIMINAR PRODUCTO
@app.route('/eliminar_producto_sanchezpharma/<int:producto_id>', methods=['DELETE'])
@jwt_required()
def eliminar_producto_sanchezpharma(producto_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Las imágenes se eliminan automáticamente por CASCADE
                cursor.execute("DELETE FROM productos WHERE id = %s", (producto_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Producto eliminado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# GESTIÓN DE IMÁGENES DE PRODUCTOS
# ---------------------------------------------------

# SUBIR IMÁGENES DE PRODUCTO
@app.route('/subir_imagenes_producto_sanchezpharma', methods=['POST'])
@jwt_required()
def subir_imagenes_producto_sanchezpharma():
    """
    Endpoint para subir imágenes de productos.
    Acepta múltiples archivos y retorna las URLs de las imágenes guardadas.
    """
    try:
        # Verificar que se hayan enviado archivos
        if 'imagenes' not in request.files:
            return jsonify({"code": 0, "message": "No se recibieron archivos"}), 400
        
        archivos = request.files.getlist('imagenes')
        
        if not archivos or len(archivos) == 0:
            return jsonify({"code": 0, "message": "No se recibieron archivos"}), 400
        
        # Crear directorio para imágenes si no existe
        # En PythonAnywhere, los archivos estáticos se guardan en /home/usuario/mysite/static/
        upload_dir = '/home/nxlsxx/mysite/static/uploads/productos'
        os.makedirs(upload_dir, exist_ok=True)
        
        # Extensiones permitidas
        ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
        
        def allowed_file(filename):
            return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
        
        urls_subidas = []
        
        for archivo in archivos:
            if archivo.filename == '':
                continue
            
            if not allowed_file(archivo.filename):
                logging.warning(f"Archivo con extensión no permitida: {archivo.filename}")
                continue
            
            # Generar nombre único para el archivo
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
            filename = secure_filename(archivo.filename)
            nombre_base, extension = os.path.splitext(filename)
            nombre_archivo = f"{nombre_base}_{timestamp}{extension}"
            
            # Ruta completa del archivo
            filepath = os.path.join(upload_dir, nombre_archivo)
            
            try:
                # Guardar archivo
                archivo.save(filepath)
                
                # Verificar que el archivo se guardó correctamente
                if not os.path.exists(filepath):
                    logging.error(f"No se pudo guardar el archivo: {filepath}")
                    continue
                
                # Generar URL pública
                # En PythonAnywhere, las carpetas static se sirven desde /static/
                url_imagen = f"https://nxlsxx.pythonanywhere.com/static/uploads/productos/{nombre_archivo}"
                
                urls_subidas.append(url_imagen)
                logging.info(f"Imagen guardada: {filepath} -> {url_imagen}")
            except Exception as save_error:
                logging.error(f"Error al guardar archivo {archivo.filename}: {repr(save_error)}")
                continue
        
        if not urls_subidas:
            return jsonify({"code": 0, "message": "No se pudieron guardar las imágenes. Verifica que sean archivos válidos (png, jpg, jpeg, gif, webp)"}), 400
        
        return jsonify({
            "code": 1,
            "message": f"{len(urls_subidas)} imagen(es) subida(s) correctamente",
            "urls": urls_subidas
        })
    
    except Exception as e:
        logging.error(f"Error al subir imágenes: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error al subir imágenes: {str(e)}"}), 500


# AGREGAR IMAGEN A PRODUCTO
@app.route('/agregar_imagen_producto_sanchezpharma', methods=['POST'])
@jwt_required()
def agregar_imagen_producto_sanchezpharma():
    try:
        data = request.json
        producto_id = data.get("producto_id")
        imagen_url = data.get("imagen_url")
        
        if not producto_id or not imagen_url:
            return jsonify({"code": 0, "message": "producto_id e imagen_url son requeridos"})
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener el siguiente orden
                cursor.execute("""
                    SELECT COALESCE(MAX(orden), -1) + 1 as siguiente_orden
                    FROM imagenes_productos 
                    WHERE producto_id = %s
                """, (producto_id,))
                resultado = cursor.fetchone()
                siguiente_orden = resultado['siguiente_orden'] if resultado else 0
                
                cursor.execute("""
                    INSERT INTO imagenes_productos (producto_id, imagen_url, orden)
                    VALUES (%s, %s, %s)
                """, (producto_id, imagen_url, siguiente_orden))
                imagen_id = cursor.lastrowid
            conn.commit()
        
        return jsonify({"code": 1, "message": "Imagen agregada correctamente", "imagen_id": imagen_id})
    
    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ELIMINAR IMAGEN DE PRODUCTO
@app.route('/eliminar_imagen_producto_sanchezpharma/<int:imagen_id>', methods=['DELETE'])
@jwt_required()
def eliminar_imagen_producto_sanchezpharma(imagen_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM imagenes_productos WHERE id = %s", (imagen_id,))
            conn.commit()
        
        return jsonify({"code": 1, "message": "Imagen eliminada correctamente"})
    
    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# OBTENER IMÁGENES DE UN PRODUCTO
@app.route('/imagenes_producto_sanchezpharma/<int:producto_id>')
@jwt_required()
def imagenes_producto_sanchezpharma(producto_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT id, imagen_url, orden 
                    FROM imagenes_productos 
                    WHERE producto_id = %s 
                    ORDER BY orden ASC
                """, (producto_id,))
                data = cursor.fetchall()
        
        return jsonify({"code": 1, "data": data, "message": "Imágenes obtenidas correctamente"})
    
    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# BUSCAR PRODUCTOS
@app.route('/buscar_productos_sanchezpharma')
@jwt_required()
def buscar_productos_sanchezpharma():
    try:
        busqueda = request.args.get('q', '')
        categoria_id = request.args.get('categoria_id')
        proveedor_id = request.args.get('proveedor_id')

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT p.*, c.nombre as categoria_nombre, pr.nombre as proveedor_nombre
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN proveedores pr ON p.proveedor_id = pr.id
                    WHERE 1=1
                """
                params = []

                if busqueda:
                    query += " AND (p.nombre LIKE %s OR p.codigo LIKE %s OR p.codigo_barras LIKE %s)"
                    params.extend([f"%{busqueda}%", f"%{busqueda}%", f"%{busqueda}%"])

                if categoria_id:
                    query += " AND p.categoria_id = %s"
                    params.append(categoria_id)

                if proveedor_id:
                    query += " AND p.proveedor_id = %s"
                    params.append(proveedor_id)

                query += " ORDER BY p.nombre"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Búsqueda realizada correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# PRODUCTOS CON STOCK BAJO
@app.route('/productos_stock_bajo_sanchezpharma')
@jwt_required()
def productos_stock_bajo_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT p.*, c.nombre as categoria_nombre, pr.nombre as proveedor_nombre,
                           (p.stock_minimo - p.stock_actual) as faltante
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN proveedores pr ON p.proveedor_id = pr.id
                    WHERE p.stock_actual <= p.stock_minimo AND p.estado = 'activo'
                    ORDER BY faltante DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Productos con stock bajo listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# PRODUCTOS PRÓXIMOS A VENCER
@app.route('/productos_proximos_vencer_sanchezpharma')
@jwt_required()
def productos_proximos_vencer_sanchezpharma():
    try:
        dias = request.args.get('dias', 30, type=int)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT p.*, c.nombre as categoria_nombre, pr.nombre as proveedor_nombre,
                           DATEDIFF(p.fecha_vencimiento, CURDATE()) as dias_restantes
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN proveedores pr ON p.proveedor_id = pr.id
                    WHERE p.fecha_vencimiento IS NOT NULL
                    AND p.fecha_vencimiento BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL %s DAY)
                    AND p.estado = 'activo'
                    ORDER BY p.fecha_vencimiento ASC
                """, (dias,))
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Productos próximos a vencer listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# ---------------------------------------------------
# INVENTARIO - CATEGORÍAS
# ---------------------------------------------------

# LISTAR CATEGORÍAS
@app.route('/categorias_sanchezpharma')
@jwt_required()
def categorias_sanchezpharma():
    try:
        estado = request.args.get('estado')  # Opcional: 'activo', 'inactivo', o None para todas
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                if estado:
                    cursor.execute("SELECT * FROM categorias WHERE estado = %s ORDER BY nombre", (estado,))
                else:
                    cursor.execute("SELECT * FROM categorias ORDER BY nombre")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Categorías listadas correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REGISTRAR CATEGORÍA
@app.route('/registrar_categoria_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_categoria_sanchezpharma():
    try:
        data = request.json

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO categorias (nombre, descripcion, estado)
                    VALUES (%s, %s, %s)
                """, (
                    data.get("nombre"),
                    data.get("descripcion"),
                    data.get("estado", "activo")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Categoría registrada correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR CATEGORÍA
@app.route('/editar_categoria_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_categoria_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID de la categoría"})

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE categorias 
                    SET nombre = %s, descripcion = %s, estado = %s
                    WHERE id = %s
                """, (
                    data.get("nombre"),
                    data.get("descripcion"),
                    data.get("estado", "activo"),
                    data.get("id")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Categoría actualizada correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# INVENTARIO - PROVEEDORES
# ---------------------------------------------------

# LISTAR PROVEEDORES
@app.route('/proveedores_sanchezpharma')
@jwt_required()
def proveedores_sanchezpharma():
    try:
        estado = request.args.get('estado')  # Opcional: 'activo', 'inactivo', o None para todas
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                if estado:
                    cursor.execute("SELECT * FROM proveedores WHERE estado = %s ORDER BY nombre", (estado,))
                else:
                    cursor.execute("SELECT * FROM proveedores ORDER BY nombre")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Proveedores listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REGISTRAR PROVEEDOR
@app.route('/registrar_proveedor_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_proveedor_sanchezpharma():
    try:
        data = request.json

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO proveedores (nombre, contacto, telefono, email, direccion, estado)
                    VALUES (%s, %s, %s, %s, %s, %s)
                """, (
                    data.get("nombre"),
                    data.get("contacto"),
                    data.get("telefono"),
                    data.get("email"),
                    data.get("direccion"),
                    data.get("estado", "activo")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Proveedor registrado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR PROVEEDOR
@app.route('/editar_proveedor_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_proveedor_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID del proveedor"})

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE proveedores 
                    SET nombre = %s, contacto = %s, telefono = %s, 
                        email = %s, direccion = %s, estado = %s
                    WHERE id = %s
                """, (
                    data.get("nombre"),
                    data.get("contacto"),
                    data.get("telefono"),
                    data.get("email"),
                    data.get("direccion"),
                    data.get("estado", "activo"),
                    data.get("id")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Proveedor actualizado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# INVENTARIO - MOVIMIENTOS
# ---------------------------------------------------

# LISTAR MOVIMIENTOS DE INVENTARIO
@app.route('/movimientos_inventario_sanchezpharma')
@jwt_required()
def movimientos_inventario_sanchezpharma():
    try:
        producto_id = request.args.get('producto_id')
        fecha_desde = request.args.get('fecha_desde')
        fecha_hasta = request.args.get('fecha_hasta')

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT m.*, p.nombre as producto_nombre, p.codigo as producto_codigo,
                           tm.nombre as tipo_movimiento_nombre, tm.tipo as tipo_movimiento_tipo,
                           u.username as usuario_nombre
                    FROM movimientos_inventario m
                    LEFT JOIN productos p ON m.producto_id = p.id
                    LEFT JOIN tipo_movimiento tm ON m.tipo_movimiento_id = tm.id
                    LEFT JOIN usuarios u ON m.usuario_id = u.id
                    WHERE 1=1
                """
                params = []

                if producto_id:
                    query += " AND m.producto_id = %s"
                    params.append(producto_id)

                if fecha_desde:
                    query += " AND DATE(m.fecha_movimiento) >= %s"
                    params.append(fecha_desde)

                if fecha_hasta:
                    query += " AND DATE(m.fecha_movimiento) <= %s"
                    params.append(fecha_hasta)

                query += " ORDER BY m.fecha_movimiento DESC LIMIT 100"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Movimientos listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REGISTRAR MOVIMIENTO DE INVENTARIO
@app.route('/registrar_movimiento_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_movimiento_sanchezpharma():
    try:
        data = request.json

        campos = ["producto_id", "tipo_movimiento_id", "cantidad"]
        if not all(data.get(c) for c in campos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener stock actual
                cursor.execute("SELECT stock_actual FROM productos WHERE id = %s", (data.get("producto_id"),))
                producto = cursor.fetchone()

                if not producto:
                    return jsonify({"code": 0, "message": "Producto no encontrado"})

                stock_anterior = producto["stock_actual"]

                # Obtener tipo de movimiento
                cursor.execute("SELECT tipo FROM tipo_movimiento WHERE id = %s", (data.get("tipo_movimiento_id"),))
                tipo_mov = cursor.fetchone()

                if not tipo_mov:
                    return jsonify({"code": 0, "message": "Tipo de movimiento no encontrado"})

                cantidad = data.get("cantidad")
                if tipo_mov["tipo"] == "salida":
                    stock_nuevo = stock_anterior - cantidad
                    if stock_nuevo < 0:
                        return jsonify({"code": 0, "message": "Stock insuficiente"})
                else:
                    stock_nuevo = stock_anterior + cantidad

                # Registrar movimiento
                cursor.execute("""
                    INSERT INTO movimientos_inventario 
                    (producto_id, tipo_movimiento_id, cantidad, stock_anterior, stock_nuevo,
                     precio_unitario, motivo, referencia, usuario_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("producto_id"),
                    data.get("tipo_movimiento_id"),
                    cantidad,
                    stock_anterior,
                    stock_nuevo,
                    data.get("precio_unitario"),
                    data.get("motivo"),
                    data.get("referencia"),
                    data.get("usuario_id")
                ))

                # Actualizar stock del producto
                cursor.execute("""
                    UPDATE productos 
                    SET stock_actual = %s,
                        estado = CASE 
                            WHEN %s <= 0 THEN 'agotado'
                            WHEN %s <= stock_minimo THEN 'activo'
                            ELSE 'activo'
                        END
                    WHERE id = %s
                """, (stock_nuevo, stock_nuevo, stock_nuevo, data.get("producto_id")))

            conn.commit()

        return jsonify({"code": 1, "message": "Movimiento registrado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# LISTAR TIPOS DE MOVIMIENTO
@app.route('/tipos_movimiento_sanchezpharma')
@jwt_required()
def tipos_movimiento_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM tipo_movimiento ORDER BY tipo, nombre")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Tipos de movimiento listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# ---------------------------------------------------
# INVENTARIO - ALERTAS
# ---------------------------------------------------

# LISTAR ALERTAS DE INVENTARIO
@app.route('/alertas_inventario_sanchezpharma')
@jwt_required()
def alertas_inventario_sanchezpharma():
    try:
        tipo_alerta = request.args.get('tipo_alerta')
        leida = request.args.get('leida')

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT a.*, p.nombre as producto_nombre, p.codigo as producto_codigo
                    FROM alertas_inventario a
                    LEFT JOIN productos p ON a.producto_id = p.id
                    WHERE 1=1
                """
                params = []

                if tipo_alerta:
                    query += " AND a.tipo_alerta = %s"
                    params.append(tipo_alerta)

                if leida is not None:
                    query += " AND a.leida = %s"
                    params.append(leida == 'true')

                query += " ORDER BY a.fecha_alerta DESC"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Alertas listadas correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# MARCAR ALERTA COMO LEÍDA
@app.route('/marcar_alerta_leida_sanchezpharma/<int:alerta_id>', methods=['PUT'])
@jwt_required()
def marcar_alerta_leida_sanchezpharma(alerta_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE alertas_inventario 
                    SET leida = TRUE, fecha_leida = NOW()
                    WHERE id = %s
                """, (alerta_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Alerta marcada como leída"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# VENTAS - CLIENTES
# ---------------------------------------------------

# LISTAR CLIENTES
@app.route('/clientes_sanchezpharma')
@jwt_required()
def clientes_sanchezpharma():
    try:
        estado = request.args.get('estado')
        busqueda = request.args.get('q', '')
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = "SELECT * FROM clientes WHERE 1=1"
                params = []
                
                if estado:
                    query += " AND estado = %s"
                    params.append(estado)
                
                if busqueda:
                    query += " AND (nombres LIKE %s OR apellido_paterno LIKE %s OR apellido_materno LIKE %s OR documento LIKE %s)"
                    params.extend([f"%{busqueda}%", f"%{busqueda}%", f"%{busqueda}%", f"%{busqueda}%"])
                
                query += " ORDER BY nombres"
                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Clientes listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VERIFICAR SI DOCUMENTO EXISTE EN BD (PÚBLICO - SIN AUTENTICACIÓN)
@app.route('/verificar_documento_sanchezpharma', methods=['GET'])
def verificar_documento_sanchezpharma():
    try:
        documento = request.args.get('documento')
        tipo_documento = request.args.get('tipo_documento', 'DNI')
        
        if not documento:
            return jsonify({"code": 0, "existe": False, "message": "Documento no proporcionado"})
        
        conn = obtenerconexion_sanchezpharma()
        existe = False
        
        with conn:
            with conn.cursor() as cursor:
                # Verificar si el documento existe en clientes
                cursor.execute("SELECT id, email, google_id, password FROM clientes WHERE documento = %s", (documento,))
                cliente = cursor.fetchone()
                
                if cliente:
                    existe = True
                    return jsonify({
                        "code": 1,
                        "existe": True,
                        "message": "El documento ya está registrado",
                        "tiene_google": bool(cliente.get("google_id")),
                        "tiene_password": bool(cliente.get("password"))
                    })
        
        return jsonify({
            "code": 1,
            "existe": False,
            "message": "El documento no está registrado"
        })
        
    except Exception as e:
        logging.error(f"Error al verificar documento: {repr(e)}")
        return jsonify({"code": 0, "existe": False, "message": f"Error al verificar documento: {str(e)}"})


# REGISTRAR CLIENTE (PÚBLICO - SIN AUTENTICACIÓN)
@app.route('/registrar_cliente_publico_sanchezpharma', methods=['POST'])
def registrar_cliente_publico_sanchezpharma():
    try:
        data = request.json

        # Validar campos requeridos
        campos_requeridos = ["nombres", "apellido_paterno", "email", "password", "documento"]
        if not all(data.get(c) for c in campos_requeridos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos: nombres, apellido_paterno, email, password, documento"})

        # Verificar DNI con RENIEC (la verificación principal se hace desde el cliente, pero validamos aquí también)
        documento = data.get("documento")
        tipo_documento = data.get("tipo_documento", "DNI")
        
        if documento and tipo_documento == "DNI":
            try:
                verificacion_dni = verificar_dni_reniec(documento)
                # Solo bloquear si el DNI no es válido Y NO es un error de conexión
                if not verificacion_dni['valido'] and not verificacion_dni.get('error_conexion', False):
                    # Bloquear el registro si el DNI no es válido (pero no si fue un error de conexión)
                    # La verificación principal se hace desde el cliente, pero validamos aquí como medida de seguridad
                    return jsonify({
                        "code": 0, 
                        "message": f"El DNI no pudo ser verificado: {verificacion_dni['mensaje']}. Por favor, verifique que el número sea correcto."
                    })
                elif verificacion_dni.get('error_conexion', False):
                    # Si es un error de conexión, permitir el registro ya que la verificación principal se hace desde el cliente
                    logging.warning(f"Advertencia: Error de conexión al verificar DNI {documento} en el servidor. El registro continúa porque la verificación se realiza desde el cliente.")
                else:
                    logging.info(f"DNI {documento} verificado correctamente con RENIEC")
            except Exception as e:
                # Si hay un error de conexión (ej: PythonAnywhere bloquea conexiones salientes),
                # permitir el registro ya que la verificación principal se hace desde el cliente
                logging.warning(f"Advertencia: No se pudo verificar DNI {documento} en el servidor debido a: {str(e)}. El registro continúa porque la verificación se realiza desde el cliente.")

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si el email ya existe en clientes
                cursor.execute("SELECT id FROM clientes WHERE email = %s", (data.get("email"),))
                cliente_con_email = cursor.fetchone()
                
                if cliente_con_email:
                    return jsonify({"code": 0, "message": "El correo electrónico ya está en uso. Por favor, use otro correo."})
                
                # Verificar si el documento ya existe en clientes
                # Permitir múltiples correos con el mismo documento solo si el documento ya existe con un correo de Google
                cursor.execute("SELECT id, google_id, password FROM clientes WHERE documento = %s", (data.get("documento"),))
                cliente_con_documento = cursor.fetchone()
                
                if cliente_con_documento:
                    # Si el documento existe con un registro de Google (tiene google_id)
                    # y el nuevo registro es normal (tiene password), permitir el registro
                    # Esto permite que una persona tenga una cuenta de Google y otra cuenta normal con el mismo documento
                    if cliente_con_documento.get("google_id"):
                        # El documento existe con un registro de Google, permitir registro normal con otro correo
                        pass  # Continuar con el registro
                    else:
                        # El documento existe con un registro normal (tiene password), no permitir duplicados
                        return jsonify({"code": 0, "message": "El número de documento ya está registrado. Por favor, verifique su documento."})
                
                # Verificar si el email existe en usuarios (no debe haber duplicados entre clientes y usuarios)
                cursor.execute("SELECT id FROM usuarios WHERE email = %s", (data.get("email"),))
                usuario_con_email = cursor.fetchone()
                
                if usuario_con_email:
                    return jsonify({"code": 0, "message": "El correo electrónico ya está en uso. Por favor, use otro correo."})

                # Verificar si el campo password existe
                cursor.execute("SHOW COLUMNS FROM clientes LIKE 'password'")
                password_exists = cursor.fetchone()
                
                if not password_exists:
                    # Si no existe el campo password, crearlo
                    cursor.execute("ALTER TABLE clientes ADD COLUMN password VARCHAR(255) AFTER email")
                    conn.commit()

                # Insertar cliente con contraseña encriptada con SHA256
                cursor.execute("""
                    INSERT INTO clientes (nombres, apellido_paterno, apellido_materno, documento, tipo_documento, 
                                         telefono, email, password, direccion, estado)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, SHA2(%s, 256), %s, %s)
                """, (
                    data.get("nombres"),
                    data.get("apellido_paterno"),
                    data.get("apellido_materno"),
                    data.get("documento"),
                    data.get("tipo_documento", "DNI"),
                    data.get("telefono"),
                    data.get("email"),
                    data.get("password"),  # Se encripta con SHA2 en la consulta
                    data.get("direccion"),
                    "activo"
                ))
                cliente_id = cursor.lastrowid
            conn.commit()

        return jsonify({
            "code": 1, 
            "message": "Cliente registrado correctamente. Ya puedes iniciar sesión.",
            "cliente_id": cliente_id
        })

    except Exception as e:
        logging.error(f"Error al registrar cliente: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error al registrar cliente: {str(e)}"})


# LOGIN/REGISTRO CON GOOGLE
@app.route('/login_google_sanchezpharma', methods=['POST'])
def login_google_sanchezpharma():
    try:
        data = request.json
        
        email = data.get("email")
        google_id = data.get("google_id")
        nombre = data.get("nombre", "")
        foto_url = data.get("foto_url")
        
        if not email or not google_id:
            return jsonify({"code": 0, "message": "Email y google_id son requeridos"})
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existe la columna google_id, si no, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM clientes LIKE 'google_id'")
                    columna_existe = cursor.fetchone()
                    
                    if not columna_existe:
                        cursor.execute("""
                            ALTER TABLE clientes 
                            ADD COLUMN google_id VARCHAR(255) NULL,
                            ADD COLUMN foto_url VARCHAR(500) NULL
                        """)
                        conn.commit()
                except Exception as e:
                    logging.warning(f"Error al verificar/crear columnas de Google: {e}")
                
                # Buscar cliente por email o google_id
                cursor.execute("""
                    SELECT id, nombres, apellido_paterno, apellido_materno, documento, telefono, direccion, estado
                    FROM clientes 
                    WHERE email = %s OR google_id = %s
                """, (email, google_id))
                cliente = cursor.fetchone()
                
                if cliente:
                    # Cliente existe, verificar si tiene datos completos
                    necesita_completar = (
                        cliente.get("documento") is None or 
                        cliente.get("documento") == "" or
                        cliente.get("telefono") is None or
                        cliente.get("telefono") == ""
                    )
                    
                    # Actualizar google_id si no lo tiene
                    cursor.execute("SELECT google_id FROM clientes WHERE id = %s", (cliente["id"],))
                    cliente_actual = cursor.fetchone()
                    if not cliente_actual.get("google_id"):
                        cursor.execute("""
                            UPDATE clientes 
                            SET google_id = %s, foto_url = %s
                            WHERE id = %s
                        """, (google_id, foto_url, cliente["id"]))
                        conn.commit()
                    
                    if necesita_completar:
                        # Necesita completar datos
                        return jsonify({
                            "code": 1,
                            "necesita_completar_datos": True,
                            "message": "Por favor, complete sus datos para continuar",
                            "cliente_id": cliente["id"]
                        })
                    else:
                        # Cliente completo, generar token JWT
                        cliente_user = UserSanchezPharma(
                            cliente["id"],
                            email,
                            ""  # No necesita password para Google
                        )
                        token = jwt.jwt_encode_callback(cliente_user)
                        
                        return jsonify({
                            "code": 1,
                            "necesita_completar_datos": False,
                            "message": "Login exitoso",
                            "token": token.decode('utf-8') if hasattr(token, 'decode') else token,
                            "cliente_id": cliente["id"]
                        })
                else:
                    # Cliente no existe, necesita registrarse
                    return jsonify({
                        "code": 1,
                        "necesita_completar_datos": True,
                        "message": "Por favor, complete sus datos para registrarse",
                        "es_nuevo": True
                    })
                    
    except Exception as e:
        logging.error(f"Error en login Google: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error: {str(e)}"})


# REGISTRAR/COMPLETAR CLIENTE CON GOOGLE
@app.route('/registrar_cliente_google_sanchezpharma', methods=['POST'])
def registrar_cliente_google_sanchezpharma():
    try:
        data = request.json
        
        campos_requeridos = ["email", "google_id", "nombres", "apellido_paterno", "documento"]
        if not all(data.get(c) for c in campos_requeridos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos: email, google_id, nombres, apellido_paterno, documento"})
        
        # Verificar DNI con RENIEC (la verificación principal se hace desde el cliente, pero validamos aquí también)
        documento = data.get("documento")
        tipo_documento = data.get("tipo_documento", "DNI")
        
        if documento and tipo_documento == "DNI":
            try:
                verificacion_dni = verificar_dni_reniec(documento)
                # Solo bloquear si el DNI no es válido Y NO es un error de conexión
                if not verificacion_dni['valido'] and not verificacion_dni.get('error_conexion', False):
                    # Bloquear el registro si el DNI no es válido (pero no si fue un error de conexión)
                    # La verificación principal se hace desde el cliente, pero validamos aquí como medida de seguridad
                    return jsonify({
                        "code": 0, 
                        "message": f"El DNI no pudo ser verificado: {verificacion_dni['mensaje']}. Por favor, verifique que el número sea correcto."
                    })
                elif verificacion_dni.get('error_conexion', False):
                    # Si es un error de conexión, permitir el registro ya que la verificación principal se hace desde el cliente
                    logging.warning(f"Advertencia: Error de conexión al verificar DNI {documento} en el servidor. El registro continúa porque la verificación se realiza desde el cliente.")
                else:
                    logging.info(f"DNI {documento} verificado correctamente con RENIEC")
            except Exception as e:
                # Si hay un error de conexión (ej: PythonAnywhere bloquea conexiones salientes),
                # permitir el registro ya que la verificación principal se hace desde el cliente
                logging.warning(f"Advertencia: No se pudo verificar DNI {documento} en el servidor debido a: {str(e)}. El registro continúa porque la verificación se realiza desde el cliente.")
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existe la columna google_id, si no, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM clientes LIKE 'google_id'")
                    columna_existe = cursor.fetchone()
                    
                    if not columna_existe:
                        cursor.execute("""
                            ALTER TABLE clientes 
                            ADD COLUMN google_id VARCHAR(255) NULL,
                            ADD COLUMN foto_url VARCHAR(500) NULL
                        """)
                        conn.commit()
                except Exception as e:
                    logging.warning(f"Error al verificar/crear columnas de Google: {e}")
                
                # Verificar si el documento ya existe
                # Permitir múltiples correos con el mismo documento solo si el documento ya existe con un registro normal
                cursor.execute("SELECT id, google_id, password FROM clientes WHERE documento = %s", (data.get("documento"),))
                cliente_con_documento = cursor.fetchone()
                
                if cliente_con_documento:
                    # Si el documento existe con un registro normal (tiene password y no tiene google_id)
                    # y el nuevo registro es de Google, permitir el registro
                    # Esto permite que una persona tenga una cuenta normal y otra cuenta de Google con el mismo documento
                    if cliente_con_documento.get("password") and not cliente_con_documento.get("google_id"):
                        # El documento existe con un registro normal, permitir registro de Google con otro correo
                        pass  # Continuar con el registro
                    else:
                        # El documento existe con un registro de Google, no permitir duplicados
                        return jsonify({"code": 0, "message": "El número de documento ya está registrado. Por favor, verifique su documento."})
                
                # Verificar si el google_id ya está en uso por otro cliente
                cursor.execute("SELECT id, email FROM clientes WHERE google_id = %s", (data.get("google_id"),))
                cliente_con_google_id = cursor.fetchone()
                
                if cliente_con_google_id and cliente_con_google_id["email"] != data.get("email"):
                    return jsonify({
                        "code": 0, 
                        "message": "Esta cuenta de Google ya está asociada a otro correo electrónico."
                    })
                
                # Verificar si el email ya existe en clientes
                cursor.execute("SELECT id FROM clientes WHERE email = %s", (data.get("email"),))
                cliente_existente = cursor.fetchone()
                
                if cliente_existente:
                    # Actualizar cliente existente
                    foto_url = data.get("foto_url") or None  # Asegurar que None se maneje correctamente
                    cursor.execute("""
                        UPDATE clientes 
                        SET nombres = %s, apellido_paterno = %s, apellido_materno = %s, documento = %s, tipo_documento = %s,
                            telefono = %s, direccion = %s, google_id = %s, foto_url = %s
                        WHERE email = %s
                    """, (
                        data.get("nombres"),
                        data.get("apellido_paterno"),
                        data.get("apellido_materno"),
                        data.get("documento"),
                        data.get("tipo_documento", "DNI"),
                        data.get("telefono"),
                        data.get("direccion"),
                        data.get("google_id"),
                        foto_url,
                        data.get("email")
                    ))
                    cliente_id = cliente_existente["id"]
                else:
                    # Crear nuevo cliente
                    foto_url = data.get("foto_url") or None  # Asegurar que None se maneje correctamente
                    cursor.execute("""
                        INSERT INTO clientes (nombres, apellido_paterno, apellido_materno, documento, tipo_documento, 
                                             telefono, email, direccion, google_id, foto_url, estado)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    """, (
                        data.get("nombres"),
                        data.get("apellido_paterno"),
                        data.get("apellido_materno"),
                        data.get("documento"),
                        data.get("tipo_documento", "DNI"),
                        data.get("telefono"),
                        data.get("email"),
                        data.get("direccion"),
                        data.get("google_id"),
                        foto_url,
                        "activo"
                    ))
                    cliente_id = cursor.lastrowid
                
                # Generar token JWT
                cliente_user = UserSanchezPharma(
                    cliente_id,
                    data.get("email"),
                    ""
                )
                token = jwt.jwt_encode_callback(cliente_user)
                
            conn.commit()
        
        return jsonify({
            "code": 1,
            "message": "Registro completado exitosamente",
            "token": token.decode('utf-8') if hasattr(token, 'decode') else token,
            "cliente_id": cliente_id
        })
        
    except Exception as e:
        error_msg = str(e)
        error_repr = repr(e)
        logging.error(f"Error al registrar cliente Google: {error_repr}")
        logging.error(f"Tipo de error: {type(e).__name__}")
        logging.error(f"Email: {data.get('email') if 'data' in locals() else 'N/A'}")
        logging.error(f"Google ID: {data.get('google_id') if 'data' in locals() else 'N/A'}")
        
        # Mensajes de error más específicos
        if "Duplicate entry" in error_msg or "duplicate key" in error_msg.lower():
            if "email" in error_msg.lower():
                return jsonify({
                    "code": 0, 
                    "message": "Este correo electrónico ya está registrado. Por favor, inicia sesión con tu cuenta."
                })
            elif "documento" in error_msg.lower():
                return jsonify({
                    "code": 0, 
                    "message": "El número de documento ya está registrado. Por favor, verifica tu documento."
                })
            elif "google_id" in error_msg.lower():
                return jsonify({
                    "code": 0, 
                    "message": "Esta cuenta de Google ya está asociada a otro usuario."
                })
            else:
                return jsonify({
                    "code": 0, 
                    "message": "Ya existe un registro con estos datos. Por favor, verifica la información."
                })
        elif "NOT NULL" in error_msg or "cannot be null" in error_msg.lower():
            return jsonify({
                "code": 0, 
                "message": "Faltan campos requeridos. Por favor, completa todos los campos obligatorios."
            })
        elif "foreign key" in error_msg.lower():
            return jsonify({
                "code": 0, 
                "message": "Error de referencia en la base de datos. Contacta al administrador."
            })
        else:
            # Ocultar detalles técnicos pero mantener información útil
            return jsonify({
                "code": 0, 
                "message": f"Error al registrar cliente: {error_msg}"
            })


# REGISTRAR CLIENTE (PRIVADO - REQUIERE AUTENTICACIÓN)
@app.route('/registrar_cliente_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_cliente_sanchezpharma():
    try:
        data = request.json

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO clientes (nombre, apellido, documento, tipo_documento, 
                                         telefono, email, direccion, estado)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("nombre"),
                    data.get("apellido"),
                    data.get("documento"),
                    data.get("tipo_documento", "DNI"),
                    data.get("telefono"),
                    data.get("email"),
                    data.get("direccion"),
                    data.get("estado", "activo")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Cliente registrado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR CLIENTE
@app.route('/editar_cliente_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_cliente_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID del cliente"})

        if not data.get("nombre"):
            return jsonify({"code": 0, "message": "El nombre es requerido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE clientes 
                    SET nombre = %s, apellido = %s, documento = %s, tipo_documento = %s,
                        telefono = %s, email = %s, direccion = %s, estado = %s,
                        genero = %s, fecha_nacimiento = %s
                    WHERE id = %s
                """, (
                    data.get("nombre"),
                    data.get("apellido"),
                    data.get("documento"),
                    data.get("tipo_documento", "DNI"),
                    data.get("telefono"),
                    data.get("email"),
                    data.get("direccion"),
                    data.get("estado", "activo"),
                    data.get("genero"),
                    data.get("fecha_nacimiento"),
                    data.get("id")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Cliente actualizado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# VENTAS - MÉTODOS DE PAGO
# ---------------------------------------------------

# LISTAR MÉTODOS DE PAGO
@app.route('/metodos_pago_sanchezpharma')
@jwt_required()
def metodos_pago_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Seleccionar solo métodos activos, ordenados por nombre
                cursor.execute("""
                    SELECT 
                        id,
                        nombre,
                        COALESCE(descripcion, '') as descripcion,
                        estado
                    FROM metodos_pago 
                    WHERE estado = 'activo' 
                    ORDER BY nombre ASC
                """)
                data = cursor.fetchall()

        # Validar que haya datos
        if not data:
            return jsonify({
                "code": 1, 
                "data": [], 
                "message": "No hay métodos de pago activos disponibles"
            })

        return jsonify({
            "code": 1, 
            "data": data, 
            "message": f"Métodos de pago listados correctamente ({len(data)} métodos encontrados)"
        })

    except Exception as e:
        logging.error(f"Error en metodos_pago_sanchezpharma: {repr(e)}")
        return jsonify({
            "code": 0, 
            "data": [], 
            "message": f"Error al obtener métodos de pago: {str(e)}"
        })


# ---------------------------------------------------
# VENTAS - VENTAS
# ---------------------------------------------------

# LISTAR VENTAS
@app.route('/ventas_sanchezpharma')
@jwt_required()
def ventas_sanchezpharma():
    try:
        fecha_desde = request.args.get('fecha_desde')
        fecha_hasta = request.args.get('fecha_hasta')
        cliente_id = request.args.get('cliente_id')
        estado = request.args.get('estado')
        tipo_venta = request.args.get('tipo_venta')

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT v.*, c.nombres as cliente_nombre, 
                           CONCAT(COALESCE(c.apellido_paterno, ''), ' ', COALESCE(c.apellido_materno, '')) as cliente_apellido,
                           c.documento as cliente_documento, u.username as usuario_nombre,
                           mp.nombre as metodo_pago_nombre
                    FROM ventas v
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    LEFT JOIN usuarios u ON v.usuario_id = u.id
                    LEFT JOIN metodos_pago mp ON v.metodo_pago_id = mp.id
                    WHERE 1=1
                """
                params = []

                if fecha_desde:
                    query += " AND DATE(v.fecha_venta) >= %s"
                    params.append(fecha_desde)

                if fecha_hasta:
                    query += " AND DATE(v.fecha_venta) <= %s"
                    params.append(fecha_hasta)

                if cliente_id:
                    query += " AND v.cliente_id = %s"
                    params.append(cliente_id)

                if estado:
                    query += " AND v.estado = %s"
                    params.append(estado)

                if tipo_venta:
                    query += " AND v.tipo_venta = %s"
                    params.append(tipo_venta)

                query += " ORDER BY v.fecha_venta DESC LIMIT 100"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas listadas correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# OBTENER VENTA POR ID
@app.route('/venta_sanchezpharma/<int:venta_id>')
@jwt_required()
def venta_sanchezpharma(venta_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener venta
                cursor.execute("""
                    SELECT v.*, c.nombres as cliente_nombre, 
                           CONCAT(COALESCE(c.apellido_paterno, ''), ' ', COALESCE(c.apellido_materno, '')) as cliente_apellido,
                           c.documento as cliente_documento, c.telefono as cliente_telefono,
                           u.username as usuario_nombre, mp.nombre as metodo_pago_nombre
                    FROM ventas v
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    LEFT JOIN usuarios u ON v.usuario_id = u.id
                    LEFT JOIN metodos_pago mp ON v.metodo_pago_id = mp.id
                    WHERE v.id = %s
                """, (venta_id,))
                venta = cursor.fetchone()

                if not venta:
                    return jsonify({"code": 0, "data": {}, "message": "Venta no encontrada"}), 404

                # Obtener detalle de venta
                cursor.execute("""
                    SELECT dv.*, p.nombre as producto_nombre, p.codigo as producto_codigo
                    FROM detalle_venta dv
                    LEFT JOIN productos p ON dv.producto_id = p.id
                    WHERE dv.venta_id = %s
                """, (venta_id,))
                detalle = cursor.fetchall()

                venta['detalle'] = detalle

        return jsonify({"code": 1, "data": venta, "message": "Venta obtenida correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# REGISTRAR VENTA
@app.route('/registrar_venta_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_venta_sanchezpharma():
    try:
        data = request.json

        campos_requeridos = ["tipo_venta", "metodo_pago_id", "productos"]
        if not all(data.get(c) for c in campos_requeridos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos"})

        productos = data.get("productos")
        if not isinstance(productos, list) or len(productos) == 0:
            return jsonify({"code": 0, "message": "Debe incluir al menos un producto"})

        # Obtener usuario_id del token JWT
        # Flask-JWT almacena el usuario actual en g.current_identity después de @jwt_required()
        current_user = getattr(g, 'current_identity', None)
        usuario_id_del_token = current_user.id if current_user else None
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Determinar usuario_id: si el usuario del token es un cliente, buscar un usuario sistema
                usuario_id_final = None
                
                # Verificar si el usuario_id del token existe en la tabla usuarios
                if usuario_id_del_token:
                    cursor.execute("SELECT id FROM usuarios WHERE id = %s", (usuario_id_del_token,))
                    usuario_existe = cursor.fetchone()
                    if usuario_existe:
                        usuario_id_final = usuario_id_del_token
                
                # Si no existe en usuarios (es un cliente), buscar un usuario sistema
                if not usuario_id_final:
                    # Buscar un usuario con rol de sistema o administrador (rol_id = 1 generalmente es admin)
                    cursor.execute("SELECT id FROM usuarios WHERE rol_id = 1 OR username = 'sistema' OR username = 'admin' LIMIT 1")
                    usuario_sistema = cursor.fetchone()
                    if usuario_sistema:
                        usuario_id_final = usuario_sistema["id"]
                    else:
                        # Si no hay usuario sistema, usar el primer usuario disponible
                        cursor.execute("SELECT id FROM usuarios ORDER BY id ASC LIMIT 1")
                        primer_usuario = cursor.fetchone()
                        if primer_usuario:
                            usuario_id_final = primer_usuario["id"]
                        else:
                            # Si no hay usuarios, permitir NULL o crear uno temporal
                            # Por ahora, permitimos NULL y el sistema debería manejarlo
                            logging.warning("No hay usuarios en el sistema. Registrando venta con usuario_id NULL.")
                            usuario_id_final = None
                
                # Calcular totales
                subtotal = Decimal('0')
                for producto in productos:
                    producto_id = producto.get("producto_id")
                    cantidad = producto.get("cantidad")
                    
                    cursor.execute("SELECT precio_venta, descuento_porcentaje, stock_actual FROM productos WHERE id = %s", (producto_id,))
                    producto_info = cursor.fetchone()
                    
                    if not producto_info:
                        return jsonify({"code": 0, "message": f"Producto {producto_id} no encontrado"})
                    
                    if producto_info["stock_actual"] < cantidad:
                        return jsonify({"code": 0, "message": f"Stock insuficiente para producto {producto_id}"})
                    
                    # Asegurar que precio_venta y cantidad sean Decimal
                    precio_venta = Decimal(str(producto_info["precio_venta"]))
                    descuento_porcentaje = Decimal(str(producto_info.get("descuento_porcentaje", 0) or 0))
                    cantidad_decimal = Decimal(str(cantidad))
                    
                    # Calcular precio con descuento si aplica
                    if descuento_porcentaje > 0:
                        descuento_producto = precio_venta * (descuento_porcentaje / Decimal('100'))
                        precio_con_descuento = precio_venta - descuento_producto
                    else:
                        precio_con_descuento = precio_venta
                    
                    subtotal += precio_con_descuento * cantidad_decimal

                # Convertir descuento a Decimal para evitar errores de tipo
                descuento_valor = data.get("descuento", 0)
                descuento = Decimal(str(descuento_valor)) if descuento_valor else Decimal('0')
                
                # Calcular total (subtotal - descuento)
                # Nota: El subtotal calculado ya incluye el IGV del 18% porque los precios_venta
                # de los productos ya incluyen el IGV (según normativa peruana)
                total = subtotal - descuento
                
                # Calcular IGV (18%) a partir del total que ya lo incluye
                # En Perú, el IGV está incluido en el precio, por lo que debemos extraerlo
                # Fórmula: IGV = Total * (0.18 / 1.18)
                #          Subtotal sin IGV = Total - IGV
                IGV_PORCENTAJE = Decimal('0.18')  # 18%
                # Calcular impuesto directamente
                impuesto = total * IGV_PORCENTAJE / (Decimal('1') + IGV_PORCENTAJE)
                # Calcular subtotal sin IGV
                subtotal_sin_igv = total - impuesto
                
                # Redondear a 2 decimales
                impuesto = round(impuesto, 2)
                subtotal_sin_igv = round(subtotal_sin_igv, 2)
                
                # Actualizar el subtotal al valor sin IGV para guardarlo correctamente
                subtotal = subtotal_sin_igv

                # Determinar el estado inicial según el tipo de venta
                # Para envío a domicilio y recojo en tienda, el estado inicial es 'pendiente'
                tipo_venta = data.get("tipo_venta")
                if tipo_venta in ['envio_domicilio', 'recojo_tienda']:
                    estado_inicial = 'pendiente'
                else:
                    # Para otros tipos de venta (venta_directa, etc.), usar el estado proporcionado o 'completada'
                    estado_inicial = data.get("estado", "completada")

                # Insertar venta
                # Si usuario_id_final es None, intentar crear un usuario sistema o usar NULL
                if usuario_id_final is None:
                    # Intentar crear un usuario sistema si no existe
                    try:
                        cursor.execute("""
                            INSERT INTO usuarios (username, email, password, nombre, apellido, rol_id)
                            SELECT 'sistema', 'sistema@sanchezpharma.com', 'sistema123', 'Sistema', 'Automático', 1
                            WHERE NOT EXISTS (SELECT 1 FROM usuarios WHERE username = 'sistema')
                        """)
                        if cursor.rowcount > 0:
                            usuario_id_final = cursor.lastrowid
                            logging.info(f"Usuario sistema creado automáticamente con ID: {usuario_id_final}")
                        else:
                            # Si ya existe, obtenerlo
                            cursor.execute("SELECT id FROM usuarios WHERE username = 'sistema' LIMIT 1")
                            usuario_sistema = cursor.fetchone()
                            if usuario_sistema:
                                usuario_id_final = usuario_sistema["id"]
                    except Exception as e:
                        logging.error(f"Error al crear usuario sistema: {e}")
                        # Si falla, intentar obtener cualquier usuario
                        cursor.execute("SELECT id FROM usuarios ORDER BY id ASC LIMIT 1")
                        primer_usuario = cursor.fetchone()
                        if primer_usuario:
                            usuario_id_final = primer_usuario["id"]
                
                # Si aún no hay usuario_id, registrar con NULL (si la tabla lo permite)
                # Verificar si existe la columna codigo_qr, si no existe, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM ventas LIKE 'codigo_qr'")
                    if not cursor.fetchone():
                        cursor.execute("ALTER TABLE ventas ADD COLUMN codigo_qr VARCHAR(255) UNIQUE AFTER numero_venta")
                        logging.info("Columna codigo_qr agregada a la tabla ventas")
                except Exception as e:
                    logging.warning(f"No se pudo verificar/crear columna codigo_qr: {e}")
                
                # Generar código QR único para la venta
                # Formato: VENTA-{venta_id}-{hash_seguridad}
                # Primero insertamos sin código QR, luego lo generamos con el ID
                cursor.execute("""
                    INSERT INTO ventas 
                    (cliente_id, usuario_id, tipo_venta, metodo_pago_id,
                     subtotal, descuento, impuesto, total, estado, observaciones)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("cliente_id"),
                    usuario_id_final,
                    data.get("tipo_venta"),
                    data.get("metodo_pago_id"),
                    subtotal,
                    descuento,
                    impuesto,
                    total,
                    estado_inicial,
                    data.get("observaciones")
                ))

                venta_id = cursor.lastrowid
                
                # Generar código QR único después de obtener el ID
                import hashlib
                timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                hash_input = f"{venta_id}{timestamp}{data.get('cliente_id')}{total}"
                hash_seguridad = hashlib.md5(hash_input.encode()).hexdigest()[:8].upper()
                codigo_qr = f"VENTA-{venta_id}-{hash_seguridad}"
                
                # Actualizar la venta con el código QR
                cursor.execute("UPDATE ventas SET codigo_qr = %s WHERE id = %s", (codigo_qr, venta_id))
                
                # Verificar la fecha guardada y el estado
                cursor.execute("SELECT fecha_venta, estado, tipo_venta FROM ventas WHERE id = %s", (venta_id,))
                venta_guardada = cursor.fetchone()
                logging.info(f"Venta registrada - ID: {venta_id}, Cliente: {data.get('cliente_id')}, Total: {total}, Estado: {estado_inicial}, Tipo: {data.get('tipo_venta')}")
                logging.info(f"Fecha guardada: {venta_guardada.get('fecha_venta') if venta_guardada else 'N/A'}, Estado guardado: {venta_guardada.get('estado') if venta_guardada else 'N/A'}")
                
                # Verificar que la venta se pueda encontrar en las consultas de reportes
                cursor.execute("""
                    SELECT COUNT(*) as encontrada
                    FROM ventas
                    WHERE id = %s
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                    AND DATE(fecha_venta) = CURDATE()
                """, (venta_id,))
                venta_encontrada_hoy = cursor.fetchone()
                logging.info(f"Venta encontrada en consulta del día: {venta_encontrada_hoy.get('encontrada') if venta_encontrada_hoy else 0}")

                # Insertar detalle y actualizar stock
                for producto in productos:
                    producto_id = producto.get("producto_id")
                    cantidad = producto.get("cantidad")
                    
                    cursor.execute("SELECT precio_venta, descuento_porcentaje FROM productos WHERE id = %s", (producto_id,))
                    precio_info = cursor.fetchone()
                    precio_venta = Decimal(str(precio_info["precio_venta"]))
                    descuento_porcentaje = Decimal(str(precio_info.get("descuento_porcentaje", 0) or 0))
                    
                    # Calcular precio con descuento si aplica
                    if descuento_porcentaje > 0:
                        descuento_producto = precio_venta * (descuento_porcentaje / Decimal('100'))
                        precio = precio_venta - descuento_producto
                    else:
                        precio = precio_venta
                    
                    cantidad_decimal = Decimal(str(cantidad))
                    producto_subtotal = precio * cantidad_decimal

                    cursor.execute("""
                        INSERT INTO detalle_venta 
                        (venta_id, producto_id, cantidad, precio_unitario, subtotal)
                        VALUES (%s, %s, %s, %s, %s)
                    """, (venta_id, producto_id, cantidad, precio, producto_subtotal))

                    # Actualizar stock
                    cursor.execute("""
                        UPDATE productos 
                        SET stock_actual = stock_actual - %s,
                            estado = CASE 
                                WHEN stock_actual - %s <= 0 THEN 'agotado'
                                WHEN stock_actual - %s <= stock_minimo THEN 'activo'
                                ELSE 'activo'
                            END
                        WHERE id = %s
                    """, (cantidad, cantidad, cantidad, producto_id))

                # Si es tipo envio_domicilio, crear el envío con todos los datos
                if data.get("tipo_venta") == "envio_domicilio":
                    # Validar campos requeridos para envío
                    if not data.get("direccion_entrega") or not data.get("telefono_contacto") or not data.get("nombre_destinatario"):
                        return jsonify({"code": 0, "message": "Para envío a domicilio se requiere: dirección, teléfono y nombre del destinatario"})
                    
                    # Generar número de seguimiento
                    numero_seguimiento = f"ENV-{venta_id}-{datetime.now().strftime('%Y%m%d')}"
                    
                    # Crear o actualizar el envío (el trigger puede haberlo creado ya)
                    cursor.execute("""
                        SELECT id FROM envios WHERE venta_id = %s
                    """, (venta_id,))
                    envio_existente = cursor.fetchone()
                    
                    if envio_existente:
                        # Actualizar envío existente (creado por trigger)
                        cursor.execute("""
                            UPDATE envios 
                            SET direccion_entrega = %s,
                                telefono_contacto = %s,
                                nombre_destinatario = %s,
                                referencia_direccion = %s,
                                latitud_destino = %s,
                                longitud_destino = %s,
                                fecha_estimada_entrega = DATE_ADD(NOW(), INTERVAL 1 DAY)
                            WHERE venta_id = %s
                        """, (
                            data.get("direccion_entrega"),
                            data.get("telefono_contacto"),
                            data.get("nombre_destinatario"),
                            data.get("referencia_direccion"),
                            data.get("latitud_destino"),
                            data.get("longitud_destino"),
                            venta_id
                        ))
                    else:
                        # Crear envío si no existe
                        cursor.execute("""
                            INSERT INTO envios 
                            (venta_id, numero_seguimiento, direccion_entrega, telefono_contacto,
                             nombre_destinatario, referencia_direccion, latitud_destino, longitud_destino,
                             estado, fecha_creacion, fecha_estimada_entrega)
                            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), DATE_ADD(NOW(), INTERVAL 1 DAY))
                        """, (
                            venta_id,
                            numero_seguimiento,
                            data.get("direccion_entrega"),
                            data.get("telefono_contacto"),
                            data.get("nombre_destinatario"),
                            data.get("referencia_direccion"),
                            data.get("latitud_destino"),
                            data.get("longitud_destino"),
                            'pendiente'
                        ))

            conn.commit()

        # Enviar boleta por correo al cliente si tiene email
        try:
            # Obtener datos completos de la venta y cliente para el PDF (nueva conexión)
            # Intentar enviar correo siempre que haya una venta registrada, incluso si cliente_id es None
            conn2 = obtenerconexion_sanchezpharma()
            with conn2:
                with conn2.cursor() as cursor2:
                    cursor2.execute("""
                        SELECT v.*, c.nombre, c.apellido, c.email, c.documento, c.telefono,
                               CONCAT(c.nombre, ' ', c.apellido) as nombre_completo,
                               mp.nombre as metodo_pago_nombre
                        FROM ventas v
                        LEFT JOIN clientes c ON v.cliente_id = c.id
                        LEFT JOIN metodos_pago mp ON v.metodo_pago_id = mp.id
                        WHERE v.id = %s
                    """, (venta_id,))
                    venta_completa = cursor2.fetchone()
                    
                    if venta_completa and venta_completa.get('email'):
                        # Obtener detalle de la venta
                        cursor2.execute("""
                            SELECT dv.*, p.nombre as producto_nombre, p.descripcion as producto_descripcion
                            FROM detalle_venta dv
                            LEFT JOIN productos p ON dv.producto_id = p.id
                            WHERE dv.venta_id = %s
                        """, (venta_id,))
                        detalle = cursor2.fetchall()
                        
                        # Generar PDF
                        pdf_data = generar_pdf_boleta(venta_completa, detalle, venta_completa)
                        
                        if pdf_data:
                            # Enviar correo
                            asunto = f"Boleta de Venta #{venta_completa.get('numero_venta', venta_id)} - Sánchez Pharma"
                            cuerpo = f"""
Estimado/a {venta_completa.get('nombre_completo', 'Cliente')},

Le informamos que su pedido ha sido registrado exitosamente.

Detalles de su compra:
- Número de Venta: {venta_completa.get('numero_venta', f'#{venta_id}')}
- Fecha: {venta_completa.get('fecha_venta', datetime.now().strftime('%d/%m/%Y %H:%M'))}
- Subtotal (sin IGV): S/. {float(venta_completa.get('subtotal', 0)):.2f}
- IGV (18%): S/. {float(venta_completa.get('impuesto', 0)):.2f}
- Descuento: S/. {float(venta_completa.get('descuento', 0)):.2f}
- TOTAL: S/. {float(venta_completa.get('total', 0)):.2f}

Adjunto encontrará la boleta de venta en formato PDF con todos los detalles.

Gracias por su compra.

Atentamente,
Sánchez Pharma
                            """
                            nombre_archivo = f"Boleta_{venta_completa.get('numero_venta', venta_id)}.pdf"
                            enviar_correo_con_pdf(
                                venta_completa['email'],
                                asunto,
                                cuerpo,
                                pdf_data,
                                nombre_archivo
                            )
                            logging.info(f"Boleta enviada por correo a {venta_completa['email']} para venta {venta_id}")
                    else:
                        logging.warning(f"No se pudo enviar boleta por correo: venta_id={venta_id}, tiene_email={venta_completa.get('email') if venta_completa else False}")
        except Exception as e:
            logging.error(f"Error al enviar boleta por correo: {repr(e)}")
            # No fallar la venta si el correo falla

        return jsonify({"code": 1, "message": "Venta registrada correctamente", "venta_id": venta_id})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ANULAR VENTA
@app.route('/anular_venta_sanchezpharma/<int:venta_id>', methods=['PUT'])
@jwt_required()
def anular_venta_sanchezpharma(venta_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar que la venta existe y no está anulada
                cursor.execute("SELECT estado FROM ventas WHERE id = %s", (venta_id,))
                venta = cursor.fetchone()

                if not venta:
                    return jsonify({"code": 0, "message": "Venta no encontrada"}), 404

                if venta["estado"] == "anulada":
                    return jsonify({"code": 0, "message": "La venta ya está anulada"})

                # Obtener detalle para restaurar stock
                cursor.execute("SELECT producto_id, cantidad FROM detalle_venta WHERE venta_id = %s", (venta_id,))
                detalle = cursor.fetchall()

                # Restaurar stock
                for item in detalle:
                    cursor.execute("""
                        UPDATE productos 
                        SET stock_actual = stock_actual + %s,
                            estado = CASE 
                                WHEN stock_actual + %s > stock_minimo THEN 'activo'
                                ELSE 'activo'
                            END
                        WHERE id = %s
                    """, (item["cantidad"], item["cantidad"], item["producto_id"]))

                # Anular venta
                cursor.execute("""
                    UPDATE ventas 
                    SET estado = 'anulada'
                    WHERE id = %s
                """, (venta_id,))

            conn.commit()

        return jsonify({"code": 1, "message": "Venta anulada correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# VENTAS - ENVÍOS
# ---------------------------------------------------

# LISTAR ENVÍOS
@app.route('/envios_sanchezpharma')
@jwt_required()
def envios_sanchezpharma():
    try:
        estado = request.args.get('estado')
        fecha_desde = request.args.get('fecha_desde')
        fecha_hasta = request.args.get('fecha_hasta')
        cliente_id = request.args.get('cliente_id')  # Para que clientes puedan ver sus envíos

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT e.*, v.numero_venta, v.fecha_venta, v.total,
                           c.nombre as cliente_nombre, c.telefono as cliente_telefono
                    FROM envios e
                    LEFT JOIN ventas v ON e.venta_id = v.id
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    WHERE 1=1
                """
                params = []

                # Filtrar por cliente si se especifica (para clientes que consultan sus propios envíos)
                if cliente_id:
                    query += " AND v.cliente_id = %s"
                    params.append(cliente_id)

                # Filtrar por estado si se especifica
                if estado:
                    query += " AND e.estado = %s"
                    params.append(estado)
                # Si no se especifica estado, mostrar todos (admin puede ver todos)

                if fecha_desde:
                    query += " AND DATE(e.fecha_creacion) >= %s"
                    params.append(fecha_desde)

                if fecha_hasta:
                    query += " AND DATE(e.fecha_creacion) <= %s"
                    params.append(fecha_hasta)

                query += " ORDER BY CASE e.estado WHEN 'pendiente' THEN 1 WHEN 'preparando' THEN 2 WHEN 'en_camino' THEN 3 ELSE 4 END, e.fecha_creacion DESC"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Envíos listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# OBTENER ENVÍO POR ID
@app.route('/envio_sanchezpharma/<int:envio_id>')
@jwt_required()
def envio_sanchezpharma(envio_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT e.*, v.numero_venta, v.fecha_venta, v.total,
                           c.nombres as cliente_nombre, 
                           CONCAT(COALESCE(c.apellido_paterno, ''), ' ', COALESCE(c.apellido_materno, '')) as cliente_apellido,
                           c.telefono as cliente_telefono, c.documento as cliente_documento
                    FROM envios e
                    LEFT JOIN ventas v ON e.venta_id = v.id
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    WHERE e.id = %s
                """, (envio_id,))
                envio = cursor.fetchone()

                if not envio:
                    return jsonify({"code": 0, "data": {}, "message": "Envío no encontrado"}), 404

                # Obtener historial de estados
                cursor.execute("""
                    SELECT es.*, u.username as usuario_nombre
                    FROM estados_envio es
                    LEFT JOIN usuarios u ON es.usuario_id = u.id
                    WHERE es.envio_id = %s
                    ORDER BY es.fecha_cambio DESC
                """, (envio_id,))
                historial = cursor.fetchall()

                envio['historial_estados'] = historial

        return jsonify({"code": 1, "data": envio, "message": "Envío obtenido correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# ACTUALIZAR ESTADO DE ENVÍO
@app.route('/actualizar_estado_envio_sanchezpharma/<int:envio_id>', methods=['PUT'])
@jwt_required()
def actualizar_estado_envio_sanchezpharma(envio_id):
    try:
        data = request.json

        nuevo_estado = data.get("estado")
        if not nuevo_estado:
            return jsonify({"code": 0, "message": "El estado es requerido"})

        estados_validos = ['pendiente', 'preparando', 'en_camino', 'entregado', 'cancelado']
        if nuevo_estado not in estados_validos:
            return jsonify({"code": 0, "message": "Estado inválido"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener estado anterior y datos del cliente
                cursor.execute("""
                    SELECT e.estado, v.cliente_id, c.nombres as cliente_nombre, e.numero_seguimiento
                    FROM envios e
                    LEFT JOIN ventas v ON e.venta_id = v.id
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    WHERE e.id = %s
                """, (envio_id,))
                envio = cursor.fetchone()

                if not envio:
                    return jsonify({"code": 0, "message": "Envío no encontrado"}), 404

                estado_anterior = envio["estado"]
                cliente_id = envio.get("cliente_id")
                cliente_nombre = envio.get("cliente_nombre", "Cliente")
                numero_seguimiento = envio.get("numero_seguimiento", "")

                # Actualizar estado
                update_query = "UPDATE envios SET estado = %s, fecha_actualizacion = NOW()"
                params = [nuevo_estado]

                # Si se marca como entregado, actualizar fecha real
                if nuevo_estado == 'entregado':
                    update_query += ", fecha_real_entrega = NOW()"

                update_query += " WHERE id = %s"
                params.append(envio_id)

                cursor.execute(update_query, params)

                # Registrar cambio en historial
                cursor.execute("""
                    INSERT INTO estados_envio 
                    (envio_id, estado_anterior, estado_nuevo, usuario_id, observaciones)
                    VALUES (%s, %s, %s, %s, %s)
                """, (
                    envio_id,
                    estado_anterior,
                    nuevo_estado,
                    data.get("usuario_id"),
                    data.get("observaciones")
                ))

                # Crear notificación para el cliente
                if cliente_id:
                    mensajes_estado = {
                        'preparando': 'Tu pedido está siendo preparado',
                        'en_camino': 'Tu pedido está en camino',
                        'entregado': '¡Tu pedido ha sido entregado!',
                        'cancelado': 'Tu pedido ha sido cancelado'
                    }
                    
                    titulo = mensajes_estado.get(nuevo_estado, f'Estado actualizado: {nuevo_estado}')
                    cuerpo = f'Tu pedido {numero_seguimiento} ahora está: {nuevo_estado.replace("_", " ").title()}'
                    
                    cursor.execute("""
                        INSERT INTO notificaciones_clientes 
                        (cliente_id, titulo, cuerpo, tipo, relacion_id, leida, fecha_creacion)
                        VALUES (%s, %s, %s, 'estado_pedido', %s, FALSE, NOW())
                    """, (cliente_id, titulo, cuerpo, envio_id))

            conn.commit()

        return jsonify({"code": 1, "message": "Estado de envío actualizado correctamente"})

    except Exception as e:
        logging.error(f"Error al actualizar estado de envío: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# OBTENER CÓDIGO QR DE UNA VENTA
@app.route('/codigo_qr_venta_sanchezpharma/<int:venta_id>', methods=['GET'])
@jwt_required()
def codigo_qr_venta_sanchezpharma(venta_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existe la columna codigo_qr, si no existe, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM ventas LIKE 'codigo_qr'")
                    if not cursor.fetchone():
                        cursor.execute("ALTER TABLE ventas ADD COLUMN codigo_qr VARCHAR(255) UNIQUE AFTER numero_venta")
                        conn.commit()
                        logging.info("Columna codigo_qr agregada a la tabla ventas")
                except Exception as e:
                    logging.warning(f"No se pudo verificar/crear columna codigo_qr: {e}")
                
                cursor.execute("""
                    SELECT codigo_qr, estado, tipo_venta, cliente_id
                    FROM ventas 
                    WHERE id = %s
                """, (venta_id,))
                venta = cursor.fetchone()
                
                if not venta:
                    return jsonify({"code": 0, "message": "Venta no encontrada"}), 404
                
                # Si no tiene código QR, generarlo
                if not venta.get("codigo_qr"):
                    import hashlib
                    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                    hash_input = f"{venta_id}{timestamp}{venta.get('cliente_id')}{venta_id}"
                    hash_seguridad = hashlib.md5(hash_input.encode()).hexdigest()[:8].upper()
                    codigo_qr = f"VENTA-{venta_id}-{hash_seguridad}"
                    
                    cursor.execute("UPDATE ventas SET codigo_qr = %s WHERE id = %s", (codigo_qr, venta_id))
                    conn.commit()
                    
                    return jsonify({
                        "code": 1,
                        "data": {
                            "codigo_qr": codigo_qr,
                            "venta_id": venta_id,
                            "estado": venta.get("estado"),
                            "tipo_venta": venta.get("tipo_venta")
                        },
                        "message": "Código QR generado correctamente"
                    })
                
                return jsonify({
                    "code": 1,
                    "data": {
                        "codigo_qr": venta.get("codigo_qr"),
                        "venta_id": venta_id,
                        "estado": venta.get("estado"),
                        "tipo_venta": venta.get("tipo_venta")
                    },
                    "message": "Código QR obtenido correctamente"
                })
    
    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# VALIDAR Y MARCAR COMO ENTREGADO MEDIANTE QR
@app.route('/validar_qr_entrega_sanchezpharma', methods=['POST'])
@jwt_required()
def validar_qr_entrega_sanchezpharma():
    try:
        data = request.json
        codigo_qr = data.get("codigo_qr")
        
        if not codigo_qr:
            return jsonify({"code": 0, "message": "Código QR es requerido"}), 400
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si existe la columna codigo_qr, si no existe, crearla
                try:
                    cursor.execute("SHOW COLUMNS FROM ventas LIKE 'codigo_qr'")
                    if not cursor.fetchone():
                        cursor.execute("ALTER TABLE ventas ADD COLUMN codigo_qr VARCHAR(255) UNIQUE AFTER numero_venta")
                        conn.commit()
                        logging.info("Columna codigo_qr agregada a la tabla ventas")
                except Exception as e:
                    logging.warning(f"No se pudo verificar/crear columna codigo_qr: {e}")
                
                # Buscar venta por código QR
                cursor.execute("""
                    SELECT v.id as venta_id, v.estado, v.tipo_venta, v.cliente_id,
                           e.id as envio_id, e.estado as estado_envio
                    FROM ventas v
                    LEFT JOIN envios e ON v.id = e.venta_id
                    WHERE v.codigo_qr = %s
                """, (codigo_qr,))
                venta = cursor.fetchone()
                
                if not venta:
                    return jsonify({"code": 0, "message": "Código QR inválido o venta no encontrada"}), 404
                
                venta_id = venta["venta_id"]
                tipo_venta = venta["tipo_venta"]
                estado_actual = venta["estado"]
                envio_id = venta.get("envio_id")
                estado_envio = venta.get("estado_envio")
                
                # Verificar que el pedido no esté ya entregado
                if estado_actual == 'completada':
                    return jsonify({
                        "code": 0,
                        "message": "Este pedido ya fue entregado anteriormente",
                        "venta_id": venta_id
                    }), 400
                
                # Obtener usuario que está escaneando
                current_user = getattr(g, 'current_identity', None)
                usuario_id = current_user.id if current_user else None
                
                # Marcar venta como completada
                cursor.execute("""
                    UPDATE ventas 
                    SET estado = 'completada', fecha_actualizacion = NOW()
                    WHERE id = %s
                """, (venta_id,))
                
                # Si es envío a domicilio, también actualizar el estado del envío
                if tipo_venta == 'envio_domicilio' and envio_id:
                    if estado_envio != 'entregado':
                        cursor.execute("""
                            UPDATE envios 
                            SET estado = 'entregado', 
                                fecha_real_entrega = NOW(),
                                fecha_actualizacion = NOW()
                            WHERE id = %s
                        """, (envio_id,))
                        
                        # Registrar en historial de estados
                        cursor.execute("""
                            INSERT INTO estados_envio 
                            (envio_id, estado_anterior, estado_nuevo, usuario_id, observaciones)
                            VALUES (%s, %s, %s, %s, %s)
                        """, (envio_id, estado_envio or 'en_camino', 'entregado', usuario_id, 'Entregado mediante escaneo QR'))
                        
                        # Crear notificación para el cliente
                        # Obtener el cliente_id de la venta (ya lo tenemos de la consulta inicial)
                        cliente_id_venta = venta.get("cliente_id")
                        
                        # Obtener solo el numero_seguimiento de la tabla envios
                        cursor.execute("""
                            SELECT numero_seguimiento 
                            FROM envios 
                            WHERE id = %s
                        """, (envio_id,))
                        envio_info = cursor.fetchone()
                        
                        if cliente_id_venta and envio_info:
                            numero_seguimiento = envio_info.get("numero_seguimiento", "")
                            cursor.execute("""
                                INSERT INTO notificaciones_clientes 
                                (cliente_id, titulo, cuerpo, tipo, relacion_id, leida, fecha_creacion)
                                VALUES (%s, %s, %s, 'pedido_entregado', %s, FALSE, NOW())
                            """, (
                                cliente_id_venta,  # Usar el cliente_id de la venta
                                '¡Pedido Entregado!',
                                f'Tu pedido {numero_seguimiento} ha sido entregado exitosamente.',
                                venta_id
                            ))
                
                conn.commit()
                
                # Enviar PDF de confirmación de entrega por correo (tanto para envío a domicilio como recojo en tienda)
                try:
                    cliente_id_venta = venta.get("cliente_id")
                    if cliente_id_venta:
                        # Obtener datos completos para el PDF (nueva conexión)
                        conn2 = obtenerconexion_sanchezpharma()
                        with conn2:
                            with conn2.cursor() as cursor2:
                                # Obtener datos de la venta y cliente
                                cursor2.execute("""
                                    SELECT v.*, c.nombre, c.apellido, c.email, c.documento,
                                           CONCAT(c.nombre, ' ', c.apellido) as nombre_completo
                                    FROM ventas v
                                    LEFT JOIN clientes c ON v.cliente_id = c.id
                                    WHERE v.id = %s
                                """, (venta_id,))
                                venta_completa = cursor2.fetchone()
                                
                                if not venta_completa or not venta_completa.get('email'):
                                    logging.warning(f"No se puede enviar correo: venta_id={venta_id}, tiene_email={venta_completa.get('email') if venta_completa else False}")
                                else:
                                    # Obtener datos del envío si existe (solo para envío a domicilio)
                                    envio_completo = None
                                    if envio_id:
                                        cursor2.execute("""
                                            SELECT e.*, DATE_FORMAT(e.fecha_real_entrega, '%%d/%%m/%%Y %%H:%%i') as fecha_real_entrega,
                                                   e.conductor_repartidor as repartidor_nombre
                                            FROM envios e
                                            WHERE e.id = %s
                                        """, (envio_id,))
                                        envio_completo = cursor2.fetchone()
                                    
                                    # Si no hay envío (recojo en tienda), crear un objeto con datos básicos
                                    if not envio_completo:
                                        envio_completo = {
                                            'numero_seguimiento': venta_completa.get('numero_venta', f'#{venta_id}'),
                                            'fecha_real_entrega': datetime.now().strftime('%d/%m/%Y %H:%M'),
                                            'direccion_entrega': 'Recojo en Tienda',
                                            'nombre_destinatario': venta_completa.get('nombre_completo', 'Cliente')
                                        }
                                    
                                    # Obtener detalle de productos
                                    cursor2.execute("""
                                        SELECT dv.*, p.nombre as producto_nombre, p.descripcion as producto_descripcion
                                        FROM detalle_venta dv
                                        LEFT JOIN productos p ON dv.producto_id = p.id
                                        WHERE dv.venta_id = %s
                                    """, (venta_id,))
                                    detalle_entrega = cursor2.fetchall()
                                    
                                    # Obtener información según el tipo de venta
                                    persona_entrega_info = None
                                    tipo_venta_actual = venta_completa.get('tipo_venta', tipo_venta)
                                    
                                    if tipo_venta_actual == 'envio_domicilio':
                                        # Si es envío a domicilio, mostrar el repartidor asignado
                                        if envio_completo and envio_completo.get('conductor_repartidor'):
                                            persona_entrega_info = {
                                                'nombre_completo': envio_completo.get('conductor_repartidor'),
                                                'tipo': 'repartidor'
                                            }
                                    else:
                                        # Si es recojo en tienda, mostrar el usuario que atendió (el que escaneó el QR)
                                        if usuario_id:
                                            cursor2.execute("""
                                                SELECT u.*, CONCAT(u.nombre, ' ', u.apellido) as nombre_completo
                                                FROM usuarios u
                                                WHERE u.id = %s
                                            """, (usuario_id,))
                                            usuario_atendio = cursor2.fetchone()
                                            if usuario_atendio:
                                                persona_entrega_info = {
                                                    'nombre_completo': usuario_atendio.get('nombre_completo', usuario_atendio.get('username', 'N/A')),
                                                    'tipo': 'usuario'
                                                }
                                    
                                    # Generar PDF de confirmación
                                    pdf_data = generar_pdf_confirmacion_entrega(
                                        venta_completa, 
                                        envio_completo, 
                                        venta_completa,
                                        detalle_entrega,
                                        persona_entrega_info
                                    )
                                    
                                    if pdf_data:
                                        # Determinar número de seguimiento o número de venta
                                        numero_seguimiento = envio_completo.get('numero_seguimiento', venta_completa.get('numero_venta', f'#{venta_id}'))
                                        
                                        # Enviar correo
                                        asunto = f"Confirmación de Entrega - Pedido {numero_seguimiento} - Sánchez Pharma"
                                        cuerpo = f"""
Estimado/a {venta_completa.get('nombre_completo', 'Cliente')},

Le informamos que su pedido ha sido entregado exitosamente.

Detalles de la entrega:
- Número de Venta: {venta_completa.get('numero_venta', f'#{venta_id}')}
- Fecha de Entrega: {envio_completo.get('fecha_real_entrega', datetime.now().strftime('%d/%m/%Y %H:%M'))}
"""
                                        if tipo_venta_actual == 'envio_domicilio':
                                            cuerpo += f"- Número de Seguimiento: {numero_seguimiento}\n"
                                            cuerpo += f"- Dirección: {envio_completo.get('direccion_entrega', 'N/A')}\n"
                                        
                                        cuerpo += """
Adjunto encontrará la confirmación de entrega en formato PDF.

Gracias por confiar en nosotros.

Atentamente,
Sánchez Pharma
                                        """
                                        nombre_archivo = f"Confirmacion_Entrega_{numero_seguimiento}.pdf"
                                        enviar_correo_con_pdf(
                                            venta_completa['email'],
                                            asunto,
                                            cuerpo,
                                            pdf_data,
                                            nombre_archivo
                                        )
                                        logging.info(f"Confirmación de entrega enviada por correo a {venta_completa['email']} para venta {venta_id}")
                except Exception as e:
                    logging.error(f"Error al enviar confirmación de entrega por correo: {repr(e)}")
                    # No fallar la entrega si el correo falla
                
                return jsonify({
                    "code": 1,
                    "message": "Pedido marcado como entregado correctamente",
                    "data": {
                        "venta_id": venta_id,
                        "tipo_venta": tipo_venta,
                        "estado": "completada"
                    }
                })
    
    except Exception as e:
        logging.error(f"Error al validar QR: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)}), 500


# ACTUALIZAR INFORMACIÓN DE ENVÍO
@app.route('/actualizar_envio_sanchezpharma/<int:envio_id>', methods=['PUT'])
@jwt_required()
def actualizar_envio_sanchezpharma(envio_id):
    try:
        data = request.json

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Construir la consulta dinámicamente según los campos recibidos
                campos = []
                valores = []
                
                # Campos básicos de envío
                if data.get("direccion_entrega") is not None:
                    campos.append("direccion_entrega = %s")
                    valores.append(data.get("direccion_entrega"))
                
                if data.get("telefono_contacto") is not None:
                    campos.append("telefono_contacto = %s")
                    valores.append(data.get("telefono_contacto"))
                
                if data.get("nombre_destinatario") is not None:
                    campos.append("nombre_destinatario = %s")
                    valores.append(data.get("nombre_destinatario"))
                
                if data.get("referencia_direccion") is not None:
                    campos.append("referencia_direccion = %s")
                    valores.append(data.get("referencia_direccion"))
                
                if data.get("fecha_estimada_entrega") is not None:
                    campos.append("fecha_estimada_entrega = %s")
                    valores.append(data.get("fecha_estimada_entrega"))
                
                if data.get("conductor_repartidor") is not None:
                    campos.append("conductor_repartidor = %s")
                    valores.append(data.get("conductor_repartidor"))
                
                if data.get("costo_envio") is not None:
                    campos.append("costo_envio = %s")
                    valores.append(data.get("costo_envio"))
                
                if data.get("observaciones") is not None:
                    campos.append("observaciones = %s")
                    valores.append(data.get("observaciones"))
                
                # Coordenadas del repartidor (para seguimiento en tiempo real)
                if data.get("latitud_repartidor") is not None:
                    campos.append("latitud_repartidor = %s")
                    valores.append(data.get("latitud_repartidor"))
                
                if data.get("longitud_repartidor") is not None:
                    campos.append("longitud_repartidor = %s")
                    valores.append(data.get("longitud_repartidor"))
                
                # Siempre actualizar fecha de actualización
                campos.append("fecha_actualizacion = NOW()")
                
                if not campos:
                    return jsonify({"code": 0, "message": "No hay campos para actualizar"})
                
                # Agregar el ID del envío al final
                valores.append(envio_id)
                
                # Construir y ejecutar la consulta
                consulta = f"UPDATE envios SET {', '.join(campos)} WHERE id = %s"
                cursor.execute(consulta, valores)
            conn.commit()

        return jsonify({"code": 1, "message": "Envío actualizado correctamente"})

    except Exception as e:
        logging.error(f"Error al actualizar envío {envio_id}: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# MÓDULO DE REPORTES
# ---------------------------------------------------

# LISTAR TIPOS DE REPORTE
@app.route('/tipos_reporte_sanchezpharma')
@jwt_required()
def tipos_reporte_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM tipos_reporte WHERE estado = 'activo' ORDER BY categoria, nombre")
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Tipos de reporte listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# DASHBOARD RESUMEN
@app.route('/dashboard_resumen_sanchezpharma')
@jwt_required()
def dashboard_resumen_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar stored procedure si existe
                try:
                    cursor.callproc('dashboard_resumen')
                    results = cursor.fetchall()
                    # Si el stored procedure devuelve datos, usarlos
                    if results:
                        return jsonify({"code": 1, "data": results, "message": "Dashboard resumen obtenido correctamente"})
                except Exception as proc_error:
                    logging.warning(f"Stored procedure no disponible, usando consultas directas: {proc_error}")
                
                # Si el stored procedure no existe o no devuelve datos, calcular manualmente
                resultados = []
                
                # Obtener fecha actual del servidor para debug
                cursor.execute("SELECT NOW() as ahora, CURDATE() as hoy, DATE_SUB(NOW(), INTERVAL 5 HOUR) as ahora_peru, DATE(DATE_SUB(NOW(), INTERVAL 5 HOUR)) as hoy_peru")
                fecha_info = cursor.fetchone()
                logging.info(f"Fechas del servidor - NOW(): {fecha_info.get('ahora')}, CURDATE(): {fecha_info.get('hoy')}, Perú: {fecha_info.get('ahora_peru')}, Hoy Perú: {fecha_info.get('hoy_peru')}")
                
                # Ventas del día - usar múltiples métodos para asegurar que funcione
                # IMPORTANTE: Incluir todas las ventas excepto las anuladas (pendiente, completada, etc.)
                # Método 1: CURDATE() (zona horaria del servidor)
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE DATE(fecha_venta) = CURDATE()
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_dia = cursor.fetchone()
                logging.info(f"Ventas del día (CURDATE): {ventas_dia}")
                
                # Método 2: Ajuste UTC-5 (Perú/Lima)
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE DATE(fecha_venta) = DATE(DATE_SUB(NOW(), INTERVAL 5 HOUR))
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_dia_utc5 = cursor.fetchone()
                logging.info(f"Ventas del día (UTC-5): {ventas_dia_utc5}")
                
                # Método 3: Consulta más amplia que incluya ventas de las últimas 24 horas
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE fecha_venta >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
                    AND fecha_venta < DATE_ADD(NOW(), INTERVAL 1 DAY)
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_dia_24h = cursor.fetchone()
                logging.info(f"Ventas del día (últimas 24h): {ventas_dia_24h}")
                
                # Usar el que tenga más resultados
                if ventas_dia_24h and (ventas_dia_24h.get('cantidad', 0) or 0) > (ventas_dia.get('cantidad', 0) or 0):
                    ventas_dia = ventas_dia_24h
                    logging.info("Usando ventas del día con rango de 24 horas")
                elif ventas_dia_utc5 and (ventas_dia_utc5.get('cantidad', 0) or 0) > (ventas_dia.get('cantidad', 0) or 0):
                    ventas_dia = ventas_dia_utc5
                    logging.info("Usando ventas del día con ajuste UTC-5")
                
                # Asegurar que cantidad sea un entero
                cantidad_dia = 0
                monto_dia = 0.0
                if ventas_dia:
                    cantidad_dia = int(ventas_dia.get('cantidad', 0) or 0)
                    monto_dia = float(ventas_dia.get('monto', 0) or 0)
                    logging.info(f"Ventas del día finales - Cantidad: {cantidad_dia}, Monto: {monto_dia}")
                
                resultados.append({
                    'tipo': 'ventas_dia',
                    'cantidad': cantidad_dia,
                    'monto': monto_dia
                })
                
                # Ventas del mes - usar múltiples métodos
                # IMPORTANTE: Incluir todas las ventas excepto las anuladas (pendiente, completada, etc.)
                # Método 1: YEAR/MONTH con CURDATE()
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE YEAR(fecha_venta) = YEAR(CURDATE())
                    AND MONTH(fecha_venta) = MONTH(CURDATE())
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_mes = cursor.fetchone()
                logging.info(f"Ventas del mes (CURDATE): {ventas_mes}")
                
                # Método 2: Ajuste UTC-5
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE YEAR(fecha_venta) = YEAR(DATE_SUB(NOW(), INTERVAL 5 HOUR))
                    AND MONTH(fecha_venta) = MONTH(DATE_SUB(NOW(), INTERVAL 5 HOUR))
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_mes_utc5 = cursor.fetchone()
                logging.info(f"Ventas del mes (UTC-5): {ventas_mes_utc5}")
                
                # Método 3: Consulta más amplia usando DATE_FORMAT
                cursor.execute("""
                    SELECT 
                        COUNT(*) as cantidad, 
                        COALESCE(SUM(total), 0) as monto
                    FROM ventas
                    WHERE DATE_FORMAT(fecha_venta, '%Y-%m') = DATE_FORMAT(NOW(), '%Y-%m')
                    AND estado != 'anulada'
                    AND estado IS NOT NULL
                """)
                ventas_mes_format = cursor.fetchone()
                logging.info(f"Ventas del mes (DATE_FORMAT): {ventas_mes_format}")
                
                # Usar el que tenga más resultados
                if ventas_mes_format and (ventas_mes_format.get('cantidad', 0) or 0) > (ventas_mes.get('cantidad', 0) or 0):
                    ventas_mes = ventas_mes_format
                    logging.info("Usando ventas del mes con DATE_FORMAT")
                elif ventas_mes_utc5 and (ventas_mes_utc5.get('cantidad', 0) or 0) > (ventas_mes.get('cantidad', 0) or 0):
                    ventas_mes = ventas_mes_utc5
                    logging.info("Usando ventas del mes con ajuste UTC-5")
                
                # Asegurar que cantidad sea un entero
                cantidad_mes = 0
                monto_mes = 0.0
                if ventas_mes:
                    cantidad_mes = int(ventas_mes.get('cantidad', 0) or 0)
                    monto_mes = float(ventas_mes.get('monto', 0) or 0)
                    logging.info(f"Ventas del mes finales - Cantidad: {cantidad_mes}, Monto: {monto_mes}")
                
                # Verificar todas las ventas para debug (incluyendo estado pendiente)
                cursor.execute("""
                    SELECT 
                        COUNT(*) as total, 
                        COUNT(CASE WHEN estado = 'pendiente' THEN 1 END) as ventas_pendientes,
                        COUNT(CASE WHEN estado = 'completada' THEN 1 END) as ventas_completadas,
                        MIN(fecha_venta) as primera_venta,
                        MAX(fecha_venta) as ultima_venta,
                        COUNT(CASE WHEN DATE(fecha_venta) = CURDATE() THEN 1 END) as ventas_hoy_curdate,
                        COUNT(CASE WHEN DATE(fecha_venta) = DATE(DATE_SUB(NOW(), INTERVAL 5 HOUR)) THEN 1 END) as ventas_hoy_utc5,
                        COUNT(CASE WHEN YEAR(fecha_venta) = YEAR(CURDATE()) AND MONTH(fecha_venta) = MONTH(CURDATE()) THEN 1 END) as ventas_mes_curdate,
                        COUNT(CASE WHEN YEAR(fecha_venta) = YEAR(DATE_SUB(NOW(), INTERVAL 5 HOUR)) AND MONTH(fecha_venta) = MONTH(DATE_SUB(NOW(), INTERVAL 5 HOUR)) THEN 1 END) as ventas_mes_utc5
                    FROM ventas
                    WHERE estado != 'anulada'
                """)
                debug_info = cursor.fetchone()
                logging.info(f"Debug ventas - Total: {debug_info.get('total')}, Pendientes: {debug_info.get('ventas_pendientes')}, Completadas: {debug_info.get('ventas_completadas')}")
                logging.info(f"Debug - Primera: {debug_info.get('primera_venta')}, Última: {debug_info.get('ultima_venta')}")
                logging.info(f"Debug - Hoy (CURDATE): {debug_info.get('ventas_hoy_curdate')}, Hoy (UTC-5): {debug_info.get('ventas_hoy_utc5')}")
                logging.info(f"Debug - Mes (CURDATE): {debug_info.get('ventas_mes_curdate')}, Mes (UTC-5): {debug_info.get('ventas_mes_utc5')}")
                
                resultados.append({
                    'tipo': 'ventas_mes',
                    'cantidad': cantidad_mes,
                    'monto': monto_mes
                })
                
                # Stock bajo
                cursor.execute("""
                    SELECT COUNT(*) as cantidad
                    FROM productos
                    WHERE stock_actual <= stock_minimo
                    AND estado = 'activo'
                """)
                stock_bajo = cursor.fetchone()
                resultados.append({
                    'tipo': 'stock_bajo',
                    'cantidad': stock_bajo['cantidad'] if stock_bajo else 0,
                    'monto': 0.0
                })
                
                # Envíos pendientes
                cursor.execute("""
                    SELECT COUNT(*) as cantidad
                    FROM envios
                    WHERE estado IN ('pendiente', 'preparando', 'en_camino')
                """)
                envios_pendientes = cursor.fetchone()
                resultados.append({
                    'tipo': 'envios_pendientes',
                    'cantidad': envios_pendientes['cantidad'] if envios_pendientes else 0,
                    'monto': 0.0
                })
                
                # Valor del inventario (precio de compra)
                cursor.execute("""
                    SELECT COALESCE(SUM(stock_actual * precio_compra), 0) as monto
                    FROM productos
                    WHERE estado = 'activo'
                """)
                valor_inventario = cursor.fetchone()
                resultados.append({
                    'tipo': 'valor_inventario',
                    'cantidad': 0,
                    'monto': float(valor_inventario['monto']) if valor_inventario and valor_inventario['monto'] else 0.0
                })

        return jsonify({"code": 1, "data": resultados, "message": "Dashboard resumen obtenido correctamente"})

    except Exception as e:
        logging.error(f"Error en dashboard_resumen: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REPORTE DE VENTAS POR PERÍODO
@app.route('/reporte_ventas_periodo_sanchezpharma', methods=['POST'])
@jwt_required()
def reporte_ventas_periodo_sanchezpharma():
    try:
        data = request.json
        fecha_desde = data.get('fecha_desde')
        fecha_hasta = data.get('fecha_hasta')

        if not fecha_desde or not fecha_hasta:
            return jsonify({"code": 0, "data": [], "message": "fecha_desde y fecha_hasta son requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar stored procedure si existe
                try:
                    cursor.callproc('reporte_ventas_periodo', (fecha_desde, fecha_hasta))
                    results = cursor.fetchall()
                    if results:
                        return jsonify({"code": 1, "data": results, "message": "Reporte de ventas generado correctamente"})
                except Exception as proc_error:
                    logging.warning(f"Stored procedure no disponible, usando consulta directa: {proc_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        v.*,
                        c.nombre as cliente_nombre,
                        c.apellido as cliente_apellido,
                        mp.nombre as metodo_pago_nombre
                    FROM ventas v
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    LEFT JOIN metodos_pago mp ON v.metodo_pago_id = mp.id
                    WHERE DATE(v.fecha_venta) BETWEEN %s AND %s
                    AND v.estado != 'anulada'
                    ORDER BY v.fecha_venta DESC
                """, (fecha_desde, fecha_hasta))
                results = cursor.fetchall()

        return jsonify({"code": 1, "data": results, "message": "Reporte de ventas generado correctamente"})

    except Exception as e:
        logging.error(f"Error en reporte_ventas_periodo: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REPORTE DE PRODUCTOS MÁS VENDIDOS
@app.route('/reporte_productos_mas_vendidos_sanchezpharma', methods=['POST'])
@jwt_required()
def reporte_productos_mas_vendidos_sanchezpharma():
    try:
        data = request.json
        fecha_desde = data.get('fecha_desde', '2020-01-01')
        fecha_hasta = data.get('fecha_hasta', '2099-12-31')
        limite = data.get('limite', 10)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.callproc('reporte_productos_mas_vendidos', (fecha_desde, fecha_hasta, limite))
                results = cursor.fetchall()

        return jsonify({"code": 1, "data": results, "message": "Reporte de productos más vendidos generado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REPORTE DE INGRESOS TOTALES
@app.route('/reporte_ingresos_totales_sanchezpharma', methods=['POST'])
@jwt_required()
def reporte_ingresos_totales_sanchezpharma():
    try:
        data = request.json
        fecha_desde = data.get('fecha_desde', '2020-01-01')
        fecha_hasta = data.get('fecha_hasta', '2099-12-31')

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar stored procedure si existe
                try:
                    cursor.callproc('reporte_ingresos_totales', (fecha_desde, fecha_hasta))
                    results = cursor.fetchone()
                    if results:
                        return jsonify({"code": 1, "data": results, "message": "Reporte de ingresos totales generado correctamente"})
                except Exception as proc_error:
                    logging.warning(f"Stored procedure no disponible, usando consulta directa: {proc_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        COALESCE(SUM(total), 0) as ingreso_total,
                        COUNT(*) as total_ventas,
                        COALESCE(AVG(total), 0) as promedio_venta,
                        COALESCE(MIN(total), 0) as venta_minima,
                        COALESCE(MAX(total), 0) as venta_maxima,
                        COALESCE(SUM(CASE WHEN tipo_venta = 'recojo_tienda' THEN total ELSE 0 END), 0) as ingresos_recojo,
                        COALESCE(SUM(CASE WHEN tipo_venta = 'envio_domicilio' THEN total ELSE 0 END), 0) as ingresos_envio
                    FROM ventas
                    WHERE DATE(fecha_venta) BETWEEN %s AND %s
                    AND estado != 'anulada'
                """, (fecha_desde, fecha_hasta))
                results = cursor.fetchone()

        return jsonify({"code": 1, "data": results, "message": "Reporte de ingresos totales generado correctamente"})

    except Exception as e:
        logging.error(f"Error en reporte_ingresos_totales: {repr(e)}")
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# REPORTE DE ENVÍOS
@app.route('/reporte_envios_sanchezpharma', methods=['POST'])
@jwt_required()
def reporte_envios_sanchezpharma():
    try:
        data = request.json
        fecha_desde = data.get('fecha_desde', '2020-01-01')
        fecha_hasta = data.get('fecha_hasta', '2099-12-31')
        estado = data.get('estado', None)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar stored procedure si existe
                try:
                    cursor.callproc('reporte_envios', (fecha_desde, fecha_hasta, estado))
                    results = cursor.fetchall()
                    if results:
                        return jsonify({"code": 1, "data": results, "message": "Reporte de envíos generado correctamente"})
                except Exception as proc_error:
                    logging.warning(f"Stored procedure no disponible, usando consulta directa: {proc_error}")
                
                # Calcular directamente
                query = """
                    SELECT 
                        e.*,
                        v.numero_venta,
                        c.nombre as cliente_nombre,
                        DATEDIFF(COALESCE(e.fecha_real_entrega, CURDATE()), e.fecha_creacion) as dias_transcurridos
                    FROM envios e
                    LEFT JOIN ventas v ON e.venta_id = v.id
                    LEFT JOIN clientes c ON v.cliente_id = c.id
                    WHERE DATE(e.fecha_creacion) BETWEEN %s AND %s
                """
                params = [fecha_desde, fecha_hasta]
                
                if estado:
                    query += " AND e.estado = %s"
                    params.append(estado)
                
                query += " ORDER BY e.fecha_creacion DESC"
                
                cursor.execute(query, params)
                results = cursor.fetchall()

        return jsonify({"code": 1, "data": results, "message": "Reporte de envíos generado correctamente"})

    except Exception as e:
        logging.error(f"Error en reporte_envios: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: VENTAS DIARIAS
@app.route('/vista_ventas_diarias_sanchezpharma')
@jwt_required()
def vista_ventas_diarias_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_ventas_diarias ORDER BY fecha DESC LIMIT 30")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Ventas diarias obtenidas correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente (usando zona horaria de Perú/Lima - UTC-5)
                # IMPORTANTE: Incluir todas las ventas excepto las anuladas (pendiente, completada, etc.)
                cursor.execute("""
                    SELECT 
                        DATE(DATE_SUB(fecha_venta, INTERVAL 5 HOUR)) as fecha,
                        COUNT(*) as total_ventas,
                        COALESCE(SUM(total), 0) as ingreso_total,
                        COALESCE(AVG(total), 0) as promedio_venta
                    FROM ventas
                    WHERE estado != 'anulada'
                    AND estado IS NOT NULL
                    GROUP BY DATE(DATE_SUB(fecha_venta, INTERVAL 5 HOUR))
                    ORDER BY fecha DESC
                    LIMIT 30
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas diarias obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_ventas_diarias: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: VENTAS MENSUALES
@app.route('/vista_ventas_mensuales_sanchezpharma')
@jwt_required()
def vista_ventas_mensuales_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_ventas_mensuales ORDER BY año DESC, mes DESC LIMIT 12")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Ventas mensuales obtenidas correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente (usando zona horaria de Perú/Lima - UTC-5)
                # IMPORTANTE: Incluir todas las ventas excepto las anuladas (pendiente, completada, etc.)
                cursor.execute("""
                    SELECT 
                        MONTH(DATE_SUB(fecha_venta, INTERVAL 5 HOUR)) as mes,
                        YEAR(DATE_SUB(fecha_venta, INTERVAL 5 HOUR)) as año,
                        COUNT(*) as total_ventas,
                        COALESCE(SUM(total), 0) as ingreso_total,
                        COUNT(DISTINCT cliente_id) as clientes_unicos
                    FROM ventas
                    WHERE estado != 'anulada'
                    AND estado IS NOT NULL
                    GROUP BY YEAR(DATE_SUB(fecha_venta, INTERVAL 5 HOUR)), MONTH(DATE_SUB(fecha_venta, INTERVAL 5 HOUR))
                    ORDER BY año DESC, mes DESC
                    LIMIT 12
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas mensuales obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_ventas_mensuales: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: PRODUCTOS MÁS VENDIDOS
@app.route('/vista_productos_mas_vendidos_sanchezpharma')
@jwt_required()
def vista_productos_mas_vendidos_sanchezpharma():
    try:
        limite = request.args.get('limite', 10, type=int)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_productos_mas_vendidos LIMIT %s", (limite,))
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Productos más vendidos obtenidos correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        p.id,
                        p.nombre,
                        c.nombre as categoria_nombre,
                        COALESCE(SUM(dv.cantidad), 0) as total_vendido,
                        COALESCE(SUM(dv.subtotal), 0) as ingreso_total,
                        COUNT(DISTINCT dv.venta_id) as veces_vendido
                    FROM productos p
                    LEFT JOIN categorias c ON p.categoria_id = c.id
                    LEFT JOIN detalle_venta dv ON p.id = dv.producto_id
                    LEFT JOIN ventas v ON dv.venta_id = v.id AND v.estado != 'anulada'
                    WHERE p.estado = 'activo'
                    GROUP BY p.id, p.nombre, c.nombre
                    ORDER BY total_vendido DESC
                    LIMIT %s
                """, (limite,))
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Productos más vendidos obtenidos correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_productos_mas_vendidos: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: VENTAS POR VENDEDOR
@app.route('/vista_ventas_por_vendedor_sanchezpharma')
@jwt_required()
def vista_ventas_por_vendedor_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_ventas_por_vendedor")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Ventas por vendedor obtenidas correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        u.id,
                        u.username,
                        COUNT(v.id) as total_ventas,
                        COALESCE(SUM(v.total), 0) as ingreso_total,
                        COALESCE(AVG(v.total), 0) as promedio_venta
                    FROM usuarios u
                    LEFT JOIN ventas v ON u.id = v.usuario_id AND v.estado != 'anulada'
                    GROUP BY u.id, u.username
                    HAVING total_ventas > 0
                    ORDER BY ingreso_total DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas por vendedor obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_ventas_por_vendedor: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: VENTAS POR CLIENTE
@app.route('/vista_ventas_por_cliente_sanchezpharma')
@jwt_required()
def vista_ventas_por_cliente_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_ventas_por_cliente")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Ventas por cliente obtenidas correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        c.id,
                        c.nombres,
                        c.apellido_paterno,
                        c.apellido_materno,
                        COUNT(v.id) as total_ventas,
                        COALESCE(SUM(v.total), 0) as monto_total,
                        COALESCE(AVG(v.total), 0) as promedio_venta
                    FROM clientes c
                    LEFT JOIN ventas v ON c.id = v.cliente_id AND v.estado != 'anulada'
                    WHERE c.estado = 'activo'
                    GROUP BY c.id, c.nombres, c.apellido_paterno, c.apellido_materno
                    HAVING total_ventas > 0
                    ORDER BY monto_total DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas por cliente obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_ventas_por_cliente: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: VENTAS POR MÉTODO DE PAGO
@app.route('/vista_ventas_por_metodo_pago_sanchezpharma')
@jwt_required()
def vista_ventas_por_metodo_pago_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_ventas_por_metodo_pago")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Ventas por método de pago obtenidas correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        mp.id,
                        mp.nombre as metodo_pago,
                        COUNT(v.id) as total_ventas,
                        COALESCE(SUM(v.total), 0) as monto_total,
                        ROUND((COUNT(v.id) * 100.0 / (SELECT COUNT(*) FROM ventas WHERE estado != 'anulada')), 2) as porcentaje
                    FROM metodos_pago mp
                    LEFT JOIN ventas v ON mp.id = v.metodo_pago_id AND v.estado != 'anulada'
                    WHERE mp.estado = 'activo'
                    GROUP BY mp.id, mp.nombre
                    ORDER BY monto_total DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Ventas por método de pago obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_ventas_por_metodo_pago: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: RESUMEN DE ENVÍOS
@app.route('/vista_resumen_envios_sanchezpharma')
@jwt_required()
def vista_resumen_envios_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_resumen_envios")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Resumen de envíos obtenido correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        estado,
                        COUNT(*) as total_envios,
                        SUM(CASE WHEN estado = 'entregado' THEN 1 ELSE 0 END) as entregados,
                        AVG(CASE 
                            WHEN estado = 'entregado' AND fecha_real_entrega IS NOT NULL AND fecha_creacion IS NOT NULL
                            THEN DATEDIFF(fecha_real_entrega, fecha_creacion)
                            ELSE NULL
                        END) as dias_promedio_entrega
                    FROM envios
                    GROUP BY estado
                    ORDER BY 
                        CASE estado
                            WHEN 'pendiente' THEN 1
                            WHEN 'preparando' THEN 2
                            WHEN 'en_camino' THEN 3
                            WHEN 'entregado' THEN 4
                            ELSE 5
                        END
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Resumen de envíos obtenido correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_resumen_envios: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: ANÁLISIS DE INVENTARIO
@app.route('/vista_analisis_inventario_sanchezpharma')
@jwt_required()
def vista_analisis_inventario_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_analisis_inventario")
                    data = cursor.fetchone()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Análisis de inventario obtenido correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        COUNT(*) as total_productos,
                        SUM(CASE WHEN estado = 'activo' THEN 1 ELSE 0 END) as productos_activos,
                        SUM(CASE WHEN estado = 'agotado' THEN 1 ELSE 0 END) as productos_agotados,
                        SUM(CASE WHEN stock_actual <= stock_minimo AND estado = 'activo' THEN 1 ELSE 0 END) as productos_stock_bajo,
                        COALESCE(SUM(stock_actual * precio_compra), 0) as valor_inventario_compra,
                        COALESCE(SUM(stock_actual * precio_venta), 0) as valor_inventario_venta,
                        COALESCE(SUM(stock_actual * (precio_venta - precio_compra)), 0) as ganancia_potencial
                    FROM productos
                """)
                data = cursor.fetchone()

        return jsonify({"code": 1, "data": data, "message": "Análisis de inventario obtenido correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_analisis_inventario: {repr(e)}")
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# VISTA: ROTACIÓN DE PRODUCTOS
@app.route('/vista_rotacion_productos_sanchezpharma')
@jwt_required()
def vista_rotacion_productos_sanchezpharma():
    try:
        limite = request.args.get('limite', 50, type=int)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_rotacion_productos ORDER BY unidades_vendidas DESC LIMIT %s", (limite,))
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Rotación de productos obtenida correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente
                cursor.execute("""
                    SELECT 
                        p.id,
                        p.nombre,
                        p.stock_actual,
                        COALESCE(SUM(dv.cantidad), 0) as unidades_vendidas,
                        COUNT(DISTINCT dv.venta_id) as veces_vendido,
                        CASE 
                            WHEN p.stock_actual > 0 
                            THEN ROUND(COALESCE(SUM(dv.cantidad), 0) / p.stock_actual, 2)
                            ELSE 0
                        END as indice_rotacion
                    FROM productos p
                    LEFT JOIN detalle_venta dv ON p.id = dv.producto_id
                    LEFT JOIN ventas v ON dv.venta_id = v.id AND v.estado != 'anulada'
                    WHERE p.estado = 'activo'
                    GROUP BY p.id, p.nombre, p.stock_actual
                    ORDER BY unidades_vendidas DESC
                    LIMIT %s
                """, (limite,))
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Rotación de productos obtenida correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_rotacion_productos: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# VISTA: COMPARATIVA DE PERÍODOS
@app.route('/vista_comparativa_periodos_sanchezpharma')
@jwt_required()
def vista_comparativa_periodos_sanchezpharma():
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Intentar usar vista si existe, sino calcular directamente
                try:
                    cursor.execute("SELECT * FROM vista_comparativa_periodos")
                    data = cursor.fetchall()
                    if data:
                        return jsonify({"code": 1, "data": data, "message": "Comparativa de períodos obtenida correctamente"})
                except Exception as view_error:
                    logging.warning(f"Vista no disponible, usando consulta directa: {view_error}")
                
                # Calcular directamente - comparar últimos 3 meses
                cursor.execute("""
                    SELECT 
                        CONCAT(MONTHNAME(fecha_venta), ' ', YEAR(fecha_venta)) as periodo,
                        COUNT(*) as total_ventas,
                        COALESCE(SUM(total), 0) as ingreso_total,
                        COALESCE(AVG(total), 0) as promedio_venta,
                        COUNT(DISTINCT cliente_id) as clientes_unicos
                    FROM ventas
                    WHERE estado != 'anulada'
                    AND fecha_venta >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
                    GROUP BY YEAR(fecha_venta), MONTH(fecha_venta)
                    ORDER BY YEAR(fecha_venta) DESC, MONTH(fecha_venta) DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Comparativa de períodos obtenida correctamente"})

    except Exception as e:
        logging.error(f"Error en vista_comparativa_periodos: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# GUARDAR REPORTE GENERADO
@app.route('/guardar_reporte_sanchezpharma', methods=['POST'])
@jwt_required()
def guardar_reporte_sanchezpharma():
    try:
        data = request.json
        usuario_id = data.get('usuario_id')
        tipo_reporte_id = data.get('tipo_reporte_id')
        nombre_reporte = data.get('nombre_reporte')
        parametros = data.get('parametros', {})
        fecha_desde = data.get('fecha_desde')
        fecha_hasta = data.get('fecha_hasta')
        datos_reporte = data.get('datos_reporte', {})
        formato = data.get('formato', 'json')

        if not usuario_id or not tipo_reporte_id:
            return jsonify({"code": 0, "message": "usuario_id y tipo_reporte_id son requeridos"})

        import json
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO reportes_generados 
                    (tipo_reporte_id, usuario_id, nombre_reporte, parametros, fecha_desde, fecha_hasta, datos_reporte, formato)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    tipo_reporte_id,
                    usuario_id,
                    nombre_reporte,
                    json.dumps(parametros),
                    fecha_desde,
                    fecha_hasta,
                    json.dumps(datos_reporte),
                    formato
                ))
                reporte_id = cursor.lastrowid
            conn.commit()

        return jsonify({"code": 1, "data": {"id": reporte_id}, "message": "Reporte guardado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# LISTAR REPORTES GENERADOS
@app.route('/reportes_generados_sanchezpharma')
@jwt_required()
def reportes_generados_sanchezpharma():
    try:
        usuario_id = request.args.get('usuario_id', type=int)
        tipo_reporte_id = request.args.get('tipo_reporte_id', type=int)

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT rg.*, tr.nombre as tipo_reporte_nombre, u.username
                    FROM reportes_generados rg
                    LEFT JOIN tipos_reporte tr ON rg.tipo_reporte_id = tr.id
                    LEFT JOIN usuarios u ON rg.usuario_id = u.id
                    WHERE 1=1
                """
                params = []

                if usuario_id:
                    query += " AND rg.usuario_id = %s"
                    params.append(usuario_id)

                if tipo_reporte_id:
                    query += " AND rg.tipo_reporte_id = %s"
                    params.append(tipo_reporte_id)

                query += " ORDER BY rg.fecha_generacion DESC LIMIT 50"

                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Reportes generados listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# OBTENER REPORTE GENERADO POR ID
@app.route('/reporte_generado_sanchezpharma/<int:reporte_id>')
@jwt_required()
def reporte_generado_sanchezpharma(reporte_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT rg.*, tr.nombre as tipo_reporte_nombre, u.username
                    FROM reportes_generados rg
                    LEFT JOIN tipos_reporte tr ON rg.tipo_reporte_id = tr.id
                    LEFT JOIN usuarios u ON rg.usuario_id = u.id
                    WHERE rg.id = %s
                """, (reporte_id,))
                data = cursor.fetchone()

        if not data:
            return jsonify({"code": 0, "data": {}, "message": "Reporte no encontrado"}), 404

        return jsonify({"code": 1, "data": data, "message": "Reporte obtenido correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# ELIMINAR REPORTE GENERADO
@app.route('/eliminar_reporte_sanchezpharma/<int:reporte_id>', methods=['DELETE'])
@jwt_required()
def eliminar_reporte_sanchezpharma(reporte_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM reportes_generados WHERE id = %s", (reporte_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Reporte eliminado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# RECUPERACIÓN DE CONTRASEÑA
# ---------------------------------------------------

# ENVIAR CÓDIGO DE RECUPERACIÓN
@app.route('/enviar_codigo_recuperacion_sanchezpharma', methods=['POST'])
def enviar_codigo_recuperacion_sanchezpharma():
    """
    Endpoint público para solicitar recuperación de contraseña.
    Envía un código de 6 dígitos al correo del cliente.
    """
    try:
        data = request.json
        email = data.get("email")
        
        if not email:
            return jsonify({"code": 0, "message": "El correo electrónico es requerido"})
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar que el email existe en la tabla clientes
                cursor.execute("SELECT id, nombre FROM clientes WHERE email = %s AND estado = 'activo'", (email,))
                cliente = cursor.fetchone()
                
                if not cliente:
                    # Por seguridad, no revelar si el email existe o no
                    return jsonify({
                        "code": 1, 
                        "message": "Si el correo existe, recibirás un código de recuperación en breve."
                    })
                
                # Generar código de 6 dígitos
                codigo = ''.join(random.choices(string.digits, k=6))
                
                # Calcular fecha de expiración (15 minutos)
                fecha_creacion = datetime.now()
                fecha_expiracion = fecha_creacion + timedelta(minutes=15)
                
                # Guardar código en la base de datos
                cursor.execute("""
                    INSERT INTO codigos_recuperacion (email, codigo, fecha_creacion, fecha_expiracion, usado)
                    VALUES (%s, %s, %s, %s, FALSE)
                """, (email, codigo, fecha_creacion, fecha_expiracion))
                
            conn.commit()
        
        # Enviar correo con el código
        if not MAIL_AVAILABLE:
            logging.error("Flask-Mail no está instalado. Instala con: pip install Flask-Mail")
            return jsonify({
                "code": 0,
                "message": "El servicio de correo no está disponible. Flask-Mail no está instalado."
            })
        
        if mail is None:
            logging.error("Flask-Mail no está inicializado correctamente.")
            return jsonify({
                "code": 0,
                "message": "El servicio de correo no está disponible. Contacta al administrador."
            })
        
        try:
            logging.info(f"Preparando correo para enviar a: {email}")
            
            msg = Message(
                subject="Código de Recuperación - Sánchez Pharma",
                recipients=[email],
                sender=app.config.get('MAIL_DEFAULT_SENDER', 'uortiznelsonfab@uss.edu.pe')
            )
            
            msg.body = f"""
Hola {cliente.get('nombre', 'Cliente')},

Has solicitado recuperar tu contraseña en Sánchez Pharma.

Tu código de verificación es: {codigo}

Este código es válido por 15 minutos.

Si no solicitaste este cambio, ignora este correo.

Saludos,
Equipo de Sánchez Pharma
            """
            
            msg.html = f"""
<!DOCTYPE html>
<html>
<head>
    <style>
        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
        .header {{ background-color: #4CAF50; color: white; padding: 20px; text-align: center; border-radius: 5px 5px 0 0; }}
        .content {{ background-color: #f9f9f9; padding: 30px; border: 1px solid #ddd; }}
        .code-box {{ background-color: #4CAF50; color: white; font-size: 32px; font-weight: bold; text-align: center; padding: 20px; margin: 20px 0; border-radius: 5px; letter-spacing: 5px; }}
        .footer {{ background-color: #f1f1f1; padding: 15px; text-align: center; font-size: 12px; color: #777; border-radius: 0 0 5px 5px; }}
        .warning {{ color: #ff6b6b; margin-top: 20px; font-size: 14px; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔐 Recuperación de Contraseña</h1>
        </div>
        <div class="content">
            <p>Hola <strong>{cliente.get('nombre', 'Cliente')}</strong>,</p>
            <p>Has solicitado recuperar tu contraseña en <strong>Sánchez Pharma</strong>.</p>
            <p>Tu código de verificación es:</p>
            <div class="code-box">{codigo}</div>
            <p>⏱️ Este código es válido por <strong>15 minutos</strong>.</p>
            <p class="warning">⚠️ Si no solicitaste este cambio, ignora este correo y tu contraseña permanecerá segura.</p>
        </div>
        <div class="footer">
            <p>Este es un correo automático, por favor no respondas.</p>
            <p>&copy; 2024 Sánchez Pharma. Todos los derechos reservados.</p>
        </div>
    </div>
</body>
</html>
            """
            
            logging.info(f"Intentando enviar correo a: {email}")
            mail.send(msg)
            logging.info(f"✅ Código de recuperación enviado exitosamente a: {email}")
            
            return jsonify({
                "code": 1, 
                "message": "Código de recuperación enviado. Revisa tu correo electrónico."
            })
            
        except Exception as e:
            error_msg = str(e)
            error_repr = repr(e)
            logging.error(f"❌ Error al enviar correo a {email}: {error_repr}")
            logging.error(f"Tipo de error: {type(e).__name__}")
            logging.error(f"Detalles: {error_msg}")
            
            # Mensajes de error más específicos
            if "Authentication" in error_msg or "Username and Password not accepted" in error_msg:
                return jsonify({
                    "code": 0, 
                    "message": "Error de autenticación de correo. Verifica que la contraseña de aplicación de Google sea correcta."
                })
            elif "Errno 101" in error_msg or "Errno 101" in error_repr or "Network is unreachable" in error_msg:
                return jsonify({
                    "code": 0, 
                    "message": "No se puede conectar al servidor de correo. El servidor no tiene acceso a internet o el servicio de correo no está disponible. Contacta al administrador."
                })
            elif "Connection" in error_msg or "timeout" in error_msg or "Connection refused" in error_msg:
                return jsonify({
                    "code": 0, 
                    "message": "Error de conexión con el servidor de correo. El servidor no puede conectarse al servicio de correo electrónico."
                })
            elif "SSL" in error_msg or "TLS" in error_msg:
                return jsonify({
                    "code": 0, 
                    "message": "Error de seguridad SSL/TLS. Contacta al administrador."
                })
            else:
                # Ocultar detalles técnicos del error al usuario final
                return jsonify({
                    "code": 0, 
                    "message": "Error al enviar el correo. Por favor, intenta nuevamente más tarde o contacta al administrador si el problema persiste."
                })
    
    except Exception as e:
        logging.error(f"Error en enviar_codigo_recuperacion: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error: {str(e)}"})


# VERIFICAR CÓDIGO DE RECUPERACIÓN
@app.route('/verificar_codigo_recuperacion_sanchezpharma', methods=['POST'])
def verificar_codigo_recuperacion_sanchezpharma():
    """
    Endpoint público para verificar si el código ingresado es válido.
    """
    try:
        data = request.json
        email = data.get("email")
        codigo = data.get("codigo")
        
        if not email or not codigo:
            return jsonify({"code": 0, "message": "Email y código son requeridos"})
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Buscar código válido (no usado y no expirado)
                cursor.execute("""
                    SELECT id_codigo, fecha_expiracion 
                    FROM codigos_recuperacion 
                    WHERE email = %s 
                    AND codigo = %s 
                    AND usado = FALSE
                    ORDER BY fecha_creacion DESC
                    LIMIT 1
                """, (email, codigo))
                
                codigo_registro = cursor.fetchone()
                
                if not codigo_registro:
                    return jsonify({"code": 0, "message": "Código inválido o ya utilizado"})
                
                # Verificar si expiró
                fecha_expiracion = codigo_registro["fecha_expiracion"]
                if datetime.now() > fecha_expiracion:
                    return jsonify({"code": 0, "message": "El código ha expirado. Solicita uno nuevo."})
                
                # Código válido
                return jsonify({
                    "code": 1, 
                    "message": "Código verificado correctamente",
                    "id_codigo": codigo_registro["id_codigo"]
                })
    
    except Exception as e:
        logging.error(f"Error en verificar_codigo_recuperacion: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error: {str(e)}"})


# CAMBIAR CONTRASEÑA CON CÓDIGO DE RECUPERACIÓN
@app.route('/cambiar_password_recuperacion_sanchezpharma', methods=['POST'])
def cambiar_password_recuperacion_sanchezpharma():
    """
    Endpoint público para cambiar la contraseña usando un código válido.
    """
    try:
        data = request.json
        email = data.get("email")
        codigo = data.get("codigo")
        nueva_password = data.get("nueva_password")
        
        if not email or not codigo or not nueva_password:
            return jsonify({"code": 0, "message": "Email, código y nueva contraseña son requeridos"})
        
        if len(nueva_password) < 6:
            return jsonify({"code": 0, "message": "La contraseña debe tener al menos 6 caracteres"})
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Buscar código válido
                cursor.execute("""
                    SELECT id_codigo, fecha_expiracion 
                    FROM codigos_recuperacion 
                    WHERE email = %s 
                    AND codigo = %s 
                    AND usado = FALSE
                    ORDER BY fecha_creacion DESC
                    LIMIT 1
                """, (email, codigo))
                
                codigo_registro = cursor.fetchone()
                
                if not codigo_registro:
                    return jsonify({"code": 0, "message": "Código inválido o ya utilizado"})
                
                # Verificar si expiró
                fecha_expiracion = codigo_registro["fecha_expiracion"]
                if datetime.now() > fecha_expiracion:
                    return jsonify({"code": 0, "message": "El código ha expirado. Solicita uno nuevo."})
                
                # Verificar que el cliente existe
                cursor.execute("SELECT id FROM clientes WHERE email = %s", (email,))
                cliente = cursor.fetchone()
                
                if not cliente:
                    return jsonify({"code": 0, "message": "Cliente no encontrado"})
                
                # Actualizar contraseña del cliente (con SHA256)
                cursor.execute("""
                    UPDATE clientes 
                    SET password = SHA2(%s, 256)
                    WHERE email = %s
                """, (nueva_password, email))
                
                # Marcar código como usado
                cursor.execute("""
                    UPDATE codigos_recuperacion 
                    SET usado = TRUE, fecha_uso = NOW()
                    WHERE id_codigo = %s
                """, (codigo_registro["id_codigo"],))
                
            conn.commit()
        
        logging.info(f"Contraseña cambiada exitosamente para: {email}")
        
        return jsonify({
            "code": 1, 
            "message": "Contraseña cambiada exitosamente. Ya puedes iniciar sesión con tu nueva contraseña."
        })
    
    except Exception as e:
        logging.error(f"Error en cambiar_password_recuperacion: {repr(e)}")
        return jsonify({"code": 0, "message": f"Error: {str(e)}"})


# ---------------------------------------------------
# BANNERS PROMOCIONALES
# ---------------------------------------------------

# CREAR TABLA DE BANNERS
def crear_tabla_banners():
    """
    Crea la tabla de banners si no existe.
    """
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS banners (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        titulo VARCHAR(255) NOT NULL,
                        descripcion TEXT,
                        imagen_url VARCHAR(500) NOT NULL,
                        enlace VARCHAR(500),
                        orden INT DEFAULT 0,
                        activo BOOLEAN DEFAULT TRUE,
                        fecha_inicio DATETIME,
                        fecha_fin DATETIME,
                        fecha_creacion DATETIME DEFAULT NOW(),
                        fecha_actualizacion DATETIME DEFAULT NOW() ON UPDATE NOW(),
                        INDEX idx_activo (activo),
                        INDEX idx_orden (orden)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                """)
            conn.commit()
            logging.info("Tabla banners verificada/creada correctamente")
    except Exception as e:
        logging.error(f"Error al crear tabla banners: {repr(e)}")

crear_tabla_banners()


# LISTAR BANNERS ACTIVOS (PÚBLICO - SIN AUTENTICACIÓN)
@app.route('/banners_activos_sanchezpharma')
def banners_activos_sanchezpharma():
    """
    Endpoint público para obtener banners activos.
    """
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT id, titulo, descripcion, imagen_url, enlace, orden, activo,
                           fecha_inicio, fecha_fin, fecha_creacion, fecha_actualizacion
                    FROM banners 
                    WHERE activo = TRUE
                    AND (fecha_inicio IS NULL OR fecha_inicio <= NOW())
                    AND (fecha_fin IS NULL OR fecha_fin >= NOW())
                    ORDER BY orden ASC, fecha_creacion DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Banners activos obtenidos correctamente"})

    except Exception as e:
        logging.error(f"Error al obtener banners activos: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# LISTAR TODOS LOS BANNERS (ADMIN)
@app.route('/banners_sanchezpharma')
@jwt_required()
def banners_sanchezpharma():
    """
    Endpoint para administradores para listar todos los banners.
    """
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT * FROM banners 
                    ORDER BY orden ASC, fecha_creacion DESC
                """)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Banners listados correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# OBTENER BANNER POR ID
@app.route('/banner_sanchezpharma/<int:banner_id>')
@jwt_required()
def banner_sanchezpharma(banner_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM banners WHERE id = %s", (banner_id,))
                data = cursor.fetchone()

        if data:
            return jsonify({"code": 1, "data": data, "message": "Banner obtenido correctamente"})
        else:
            return jsonify({"code": 0, "data": {}, "message": "Banner no encontrado"}), 404

    except Exception as e:
        return jsonify({"code": 0, "data": {}, "message": repr(e)})


# REGISTRAR BANNER
@app.route('/registrar_banner_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_banner_sanchezpharma():
    try:
        data = request.json

        if not data.get("titulo") or not data.get("imagen_url"):
            return jsonify({"code": 0, "message": "Título e imagen_url son requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                activo = data.get("activo", True)
                cursor.execute("""
                    INSERT INTO banners 
                    (titulo, descripcion, imagen_url, enlace, orden, activo, fecha_inicio, fecha_fin)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("titulo"),
                    data.get("descripcion"),
                    data.get("imagen_url"),
                    data.get("enlace"),
                    data.get("orden", 0),
                    activo,
                    data.get("fecha_inicio"),
                    data.get("fecha_fin")
                ))
                banner_id = cursor.lastrowid
                
                # Si el banner está activo, crear notificación para todos los clientes activos
                if activo:
                    cursor.execute("""
                        SELECT id FROM clientes WHERE estado = 'activo'
                    """)
                    clientes = cursor.fetchall()
                    
                    titulo = '¡Nueva promoción disponible!'
                    cuerpo = data.get("titulo", "Nueva promoción")
                    if data.get("descripcion"):
                        cuerpo += f': {data.get("descripcion")[:100]}'
                    
                    for cliente in clientes:
                        cursor.execute("""
                            INSERT INTO notificaciones_clientes 
                            (cliente_id, titulo, cuerpo, tipo, relacion_id, leida, fecha_creacion)
                            VALUES (%s, %s, %s, 'promocion', %s, FALSE, NOW())
                        """, (cliente["id"], titulo, cuerpo, banner_id))
                
            conn.commit()

        return jsonify({"code": 1, "message": "Banner registrado correctamente", "banner_id": banner_id})

    except Exception as e:
        logging.error(f"Error al registrar banner: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR BANNER
@app.route('/editar_banner_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_banner_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID del banner"})

        if not data.get("titulo") or not data.get("imagen_url"):
            return jsonify({"code": 0, "message": "Título e imagen_url son requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE banners 
                    SET titulo = %s, descripcion = %s, imagen_url = %s, enlace = %s,
                        orden = %s, activo = %s, fecha_inicio = %s, fecha_fin = %s
                    WHERE id = %s
                """, (
                    data.get("titulo"),
                    data.get("descripcion"),
                    data.get("imagen_url"),
                    data.get("enlace"),
                    data.get("orden", 0),
                    data.get("activo", True),
                    data.get("fecha_inicio"),
                    data.get("fecha_fin"),
                    data.get("id")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Banner actualizado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ELIMINAR BANNER
@app.route('/eliminar_banner_sanchezpharma/<int:banner_id>', methods=['DELETE'])
@jwt_required()
def eliminar_banner_sanchezpharma(banner_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM banners WHERE id = %s", (banner_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Banner eliminado correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# CAMBIAR ESTADO DE BANNER (ACTIVAR/DESACTIVAR)
@app.route('/toggle_banner_sanchezpharma/<int:banner_id>', methods=['PUT'])
@jwt_required()
def toggle_banner_sanchezpharma(banner_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener estado actual
                cursor.execute("SELECT activo FROM banners WHERE id = %s", (banner_id,))
                banner = cursor.fetchone()
                
                if not banner:
                    return jsonify({"code": 0, "message": "Banner no encontrado"}), 404
                
                nuevo_estado = not banner["activo"]
                
                # Cambiar estado
                cursor.execute("""
                    UPDATE banners 
                    SET activo = %s
                    WHERE id = %s
                """, (nuevo_estado, banner_id))
            conn.commit()

        estado_texto = "activado" if nuevo_estado else "desactivado"
        return jsonify({"code": 1, "message": f"Banner {estado_texto} correctamente"})

    except Exception as e:
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# DIRECCIONES DE CLIENTES
# ---------------------------------------------------

# CREAR TABLA DE DIRECCIONES
def crear_tabla_direcciones():
    """
    Crea la tabla de direcciones de clientes si no existe.
    """
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS direcciones_clientes (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        cliente_id INT NOT NULL,
                        titulo VARCHAR(100) NOT NULL,
                        direccion TEXT NOT NULL,
                        referencia TEXT,
                        latitud DECIMAL(10, 8) NOT NULL,
                        longitud DECIMAL(11, 8) NOT NULL,
                        es_principal BOOLEAN DEFAULT FALSE,
                        fecha_creacion DATETIME DEFAULT NOW(),
                        fecha_actualizacion DATETIME DEFAULT NOW() ON UPDATE NOW(),
                        INDEX idx_cliente (cliente_id),
                        INDEX idx_principal (cliente_id, es_principal)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                """)
            conn.commit()
            logging.info("Tabla direcciones_clientes verificada/creada correctamente")
    except Exception as e:
        logging.error(f"Error al crear tabla direcciones_clientes: {repr(e)}")

crear_tabla_direcciones()


# ---------------------------------------------------
# NOTIFICACIONES DE CLIENTES
# ---------------------------------------------------

# CREAR TABLA DE NOTIFICACIONES
def crear_tabla_notificaciones():
    """
    Crea la tabla de notificaciones de clientes si no existe.
    """
    conn = obtenerconexion_sanchezpharma()
    try:
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS notificaciones_clientes (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        cliente_id INT NOT NULL,
                        titulo VARCHAR(255) NOT NULL,
                        cuerpo TEXT NOT NULL,
                        tipo VARCHAR(50) DEFAULT 'general',
                        relacion_id INT NULL,
                        leida BOOLEAN DEFAULT FALSE,
                        fecha_creacion DATETIME DEFAULT NOW(),
                        fecha_leida DATETIME NULL,
                        INDEX idx_cliente (cliente_id),
                        INDEX idx_leida (cliente_id, leida),
                        INDEX idx_fecha (fecha_creacion)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                """)
            conn.commit()
            logging.info("Tabla notificaciones_clientes verificada/creada correctamente")
    except Exception as e:
        logging.error(f"Error al crear tabla notificaciones_clientes: {repr(e)}")

crear_tabla_notificaciones()


# LISTAR DIRECCIONES DE UN CLIENTE
@app.route('/direcciones_cliente_sanchezpharma/<int:cliente_id>')
@jwt_required()
def direcciones_cliente_sanchezpharma(cliente_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT * FROM direcciones_clientes 
                    WHERE cliente_id = %s 
                    ORDER BY es_principal DESC, fecha_creacion DESC
                """, (cliente_id,))
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Direcciones obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error al obtener direcciones: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# REGISTRAR DIRECCIÓN
@app.route('/registrar_direccion_sanchezpharma', methods=['POST'])
@jwt_required()
def registrar_direccion_sanchezpharma():
    try:
        data = request.json

        campos = ["cliente_id", "titulo", "direccion", "latitud", "longitud"]
        if not all(data.get(c) for c in campos):
            return jsonify({"code": 0, "message": "Faltan campos requeridos"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Si es principal, desmarcar las demás
                if data.get("es_principal", False):
                    cursor.execute("""
                        UPDATE direcciones_clientes 
                        SET es_principal = FALSE 
                        WHERE cliente_id = %s
                    """, (data.get("cliente_id"),))

                cursor.execute("""
                    INSERT INTO direcciones_clientes 
                    (cliente_id, titulo, direccion, referencia, latitud, longitud, es_principal)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                """, (
                    data.get("cliente_id"),
                    data.get("titulo"),
                    data.get("direccion"),
                    data.get("referencia"),
                    data.get("latitud"),
                    data.get("longitud"),
                    data.get("es_principal", False)
                ))
                direccion_id = cursor.lastrowid
            conn.commit()

        return jsonify({"code": 1, "message": "Dirección registrada correctamente", "direccion_id": direccion_id})

    except Exception as e:
        logging.error(f"Error al registrar dirección: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# EDITAR DIRECCIÓN
@app.route('/editar_direccion_sanchezpharma', methods=['PUT'])
@jwt_required()
def editar_direccion_sanchezpharma():
    try:
        data = request.json

        if not data.get("id"):
            return jsonify({"code": 0, "message": "Falta el ID de la dirección"})

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Si es principal, desmarcar las demás
                if data.get("es_principal", False):
                    cursor.execute("""
                        SELECT cliente_id FROM direcciones_clientes WHERE id = %s
                    """, (data.get("id"),))
                    result = cursor.fetchone()
                    if result:
                        cursor.execute("""
                            UPDATE direcciones_clientes 
                            SET es_principal = FALSE 
                            WHERE cliente_id = %s AND id != %s
                        """, (result["cliente_id"], data.get("id")))

                cursor.execute("""
                    UPDATE direcciones_clientes 
                    SET titulo = %s, direccion = %s, referencia = %s,
                        latitud = %s, longitud = %s, es_principal = %s
                    WHERE id = %s
                """, (
                    data.get("titulo"),
                    data.get("direccion"),
                    data.get("referencia"),
                    data.get("latitud"),
                    data.get("longitud"),
                    data.get("es_principal", False),
                    data.get("id")
                ))
            conn.commit()

        return jsonify({"code": 1, "message": "Dirección actualizada correctamente"})

    except Exception as e:
        logging.error(f"Error al editar dirección: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# ELIMINAR DIRECCIÓN
@app.route('/eliminar_direccion_sanchezpharma/<int:direccion_id>', methods=['DELETE'])
@jwt_required()
def eliminar_direccion_sanchezpharma(direccion_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM direcciones_clientes WHERE id = %s", (direccion_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Dirección eliminada correctamente"})

    except Exception as e:
        logging.error(f"Error al eliminar dirección: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# MARCAR DIRECCIÓN COMO PRINCIPAL
@app.route('/marcar_direccion_principal_sanchezpharma/<int:direccion_id>', methods=['PUT'])
@jwt_required()
def marcar_direccion_principal_sanchezpharma(direccion_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Obtener cliente_id de la dirección
                cursor.execute("SELECT cliente_id FROM direcciones_clientes WHERE id = %s", (direccion_id,))
                result = cursor.fetchone()
                
                if not result:
                    return jsonify({"code": 0, "message": "Dirección no encontrada"}), 404
                
                cliente_id = result["cliente_id"]
                
                # Desmarcar todas las direcciones del cliente
                cursor.execute("""
                    UPDATE direcciones_clientes 
                    SET es_principal = FALSE 
                    WHERE cliente_id = %s
                """, (cliente_id,))
                
                # Marcar la dirección seleccionada como principal
                cursor.execute("""
                    UPDATE direcciones_clientes 
                    SET es_principal = TRUE 
                    WHERE id = %s
                """, (direccion_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Dirección marcada como principal"})

    except Exception as e:
        logging.error(f"Error al marcar dirección como principal: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# ---------------------------------------------------
# NOTIFICACIONES DE CLIENTES
# ---------------------------------------------------

# LISTAR NOTIFICACIONES DE UN CLIENTE
@app.route('/notificaciones_cliente_sanchezpharma/<int:cliente_id>')
@jwt_required()
def notificaciones_cliente_sanchezpharma(cliente_id):
    try:
        leida = request.args.get('leida')  # Opcional: 'true' o 'false'
        
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                query = """
                    SELECT * FROM notificaciones_clientes 
                    WHERE cliente_id = %s
                """
                params = [cliente_id]
                
                if leida is not None:
                    query += " AND leida = %s"
                    params.append(leida == 'true')
                
                query += " ORDER BY fecha_creacion DESC LIMIT 50"
                
                cursor.execute(query, params)
                data = cursor.fetchall()

        return jsonify({"code": 1, "data": data, "message": "Notificaciones obtenidas correctamente"})

    except Exception as e:
        logging.error(f"Error al obtener notificaciones: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# MARCAR NOTIFICACIÓN COMO LEÍDA
@app.route('/marcar_notificacion_leida_sanchezpharma/<int:notificacion_id>', methods=['PUT'])
@jwt_required()
def marcar_notificacion_leida_sanchezpharma(notificacion_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE notificaciones_clientes 
                    SET leida = TRUE, fecha_leida = NOW()
                    WHERE id = %s
                """, (notificacion_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Notificación marcada como leída"})

    except Exception as e:
        logging.error(f"Error al marcar notificación como leída: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# MARCAR TODAS LAS NOTIFICACIONES COMO LEÍDAS
@app.route('/marcar_todas_notificaciones_leidas_sanchezpharma/<int:cliente_id>', methods=['PUT'])
@jwt_required()
def marcar_todas_notificaciones_leidas_sanchezpharma(cliente_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    UPDATE notificaciones_clientes 
                    SET leida = TRUE, fecha_leida = NOW()
                    WHERE cliente_id = %s AND leida = FALSE
                """, (cliente_id,))
            conn.commit()

        return jsonify({"code": 1, "message": "Todas las notificaciones marcadas como leídas"})

    except Exception as e:
        logging.error(f"Error al marcar todas las notificaciones como leídas: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# CONTAR NOTIFICACIONES NO LEÍDAS
@app.route('/contar_notificaciones_no_leidas_sanchezpharma/<int:cliente_id>')
@jwt_required()
def contar_notificaciones_no_leidas_sanchezpharma(cliente_id):
    try:
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*) as total 
                    FROM notificaciones_clientes 
                    WHERE cliente_id = %s AND leida = FALSE
                """, (cliente_id,))
                result = cursor.fetchone()

        return jsonify({"code": 1, "data": {"total": result["total"]}, "message": "Conteo obtenido correctamente"})

    except Exception as e:
        logging.error(f"Error al contar notificaciones: {repr(e)}")
        return jsonify({"code": 0, "data": {"total": 0}, "message": repr(e)})


# ---------------------------------------------------
# BACKUPS (SOLO INGENIERO - ROL 6)
# ---------------------------------------------------

# OBTENER HISTORIAL DE BACKUPS
@app.route('/backups_historial_sanchezpharma')
@jwt_required()
def backups_historial_sanchezpharma():
    try:
        # Logging detallado para debugging
        auth_header = request.headers.get("Authorization")
        logging.info(f"backups_historial_sanchezpharma: Authorization header recibido: {auth_header[:50] if auth_header else 'None'}...")
        
        # Obtener usuario del token
        current_user = getattr(g, 'current_identity', None)
        logging.info(f"backups_historial_sanchezpharma: current_identity: {current_user}")
        
        if not current_user:
            # Intentar obtener información adicional del token
            try:
                token_data = getattr(g, 'jwt_payload', None)
                logging.error(f"backups_historial_sanchezpharma: Token payload: {token_data}")
                logging.error(f"backups_historial_sanchezpharma: g attributes: {[attr for attr in dir(g) if not attr.startswith('_')]}")
            except Exception as e:
                logging.error(f"backups_historial_sanchezpharma: Error al obtener info adicional: {repr(e)}")
            
            logging.error("backups_historial_sanchezpharma: current_identity es None - Token no procesado correctamente")
            return jsonify({"code": 0, "message": "Usuario no autenticado"}), 401
        
        logging.info(f"backups_historial_sanchezpharma: Usuario autenticado ID: {current_user.id}")
        
        # Obtener rol_id del usuario desde la base de datos
        # Solo usuarios internos pueden acceder (clientes no tienen rol_id)
        conn = obtenerconexion_sanchezpharma()
        rol_id = None
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT rol_id FROM usuarios WHERE id = %s", (current_user.id,))
                usuario_data = cursor.fetchone()
                
                if usuario_data:
                    rol_id = usuario_data.get('rol_id')
                    logging.info(f"backups_historial_sanchezpharma: Usuario encontrado con rol_id: {rol_id}")
                else:
                    # Si no está en usuarios, es un cliente - no tiene acceso
                    logging.warning(f"backups_historial_sanchezpharma: Usuario {current_user.id} no encontrado en tabla usuarios (probablemente es cliente)")
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo usuarios internos pueden acceder a esta sección."}), 403
                
                # Verificar que el usuario sea Ingeniero (rol_id = 6)
                if rol_id != 6:
                    logging.warning(f"backups_historial_sanchezpharma: Usuario {current_user.id} con rol_id {rol_id} intentó acceder (requiere rol_id 6)")
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo el rol Ingeniero puede acceder a esta sección."}), 403

        # Verificar si la tabla backups_historial existe, si no, crearla
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                # Verificar si la tabla existe
                cursor.execute("""
                    SELECT COUNT(*) as count 
                    FROM information_schema.tables 
                    WHERE table_schema = DATABASE() 
                    AND table_name = 'backups_historial'
                """)
                tabla_existe = cursor.fetchone()
                
                if tabla_existe and tabla_existe.get('count', 0) == 0:
                    # Crear la tabla si no existe
                    cursor.execute("""
                        CREATE TABLE IF NOT EXISTS backups_historial (
                            id INT AUTO_INCREMENT PRIMARY KEY,
                            tipo VARCHAR(50) NOT NULL COMMENT 'Tipo de backup: bd, archivos, completo',
                            nombre_archivo VARCHAR(255) NOT NULL,
                            ruta_archivo VARCHAR(500) NOT NULL,
                            tamano_bytes BIGINT,
                            usuario_id INT,
                            fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP,
                            estado VARCHAR(20) DEFAULT 'completado' COMMENT 'completado, error, en_proceso',
                            observaciones TEXT,
                            FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE SET NULL,
                            INDEX idx_fecha_creacion (fecha_creacion),
                            INDEX idx_tipo (tipo)
                        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                    """)
                    conn.commit()
                    logging.info("Tabla backups_historial creada")
                
                cursor.execute("""
                    SELECT b.*, u.username as usuario_nombre
                    FROM backups_historial b
                    LEFT JOIN usuarios u ON b.usuario_id = u.id
                    ORDER BY b.fecha_creacion DESC
                    LIMIT 100
                """)
                data = cursor.fetchall()
                
                # Convertir datetime a string para JSON
                for item in data:
                    if item.get('fecha_creacion'):
                        item['fecha_creacion'] = item['fecha_creacion'].strftime('%Y-%m-%d %H:%M:%S')

        return jsonify({"code": 1, "data": data, "message": "Historial de backups obtenido correctamente"})

    except Exception as e:
        logging.error(f"Error al obtener historial de backups: {repr(e)}")
        return jsonify({"code": 0, "data": [], "message": repr(e)})


# GENERAR BACKUP DE BASE DE DATOS
@app.route('/generar_backup_bd_sanchezpharma', methods=['POST'])
@jwt_required()
def generar_backup_bd_sanchezpharma():
    try:
        # Logging detallado para debugging
        auth_header = request.headers.get("Authorization")
        logging.info(f"generar_backup_bd_sanchezpharma: Authorization header recibido: {auth_header[:50] if auth_header else 'None'}...")
        
        # Obtener usuario del token
        current_user = getattr(g, 'current_identity', None)
        logging.info(f"generar_backup_bd_sanchezpharma: current_identity: {current_user}")
        logging.info(f"generar_backup_bd_sanchezpharma: g.current_identity type: {type(current_user)}")
        
        if not current_user:
            # Intentar obtener información adicional del token
            try:
                # Flask-JWT almacena el token decodificado en g
                token_data = getattr(g, 'jwt_payload', None)
                logging.error(f"generar_backup_bd_sanchezpharma: Token payload: {token_data}")
                logging.error(f"generar_backup_bd_sanchezpharma: g attributes: {dir(g)}")
            except Exception as e:
                logging.error(f"generar_backup_bd_sanchezpharma: Error al obtener info adicional: {repr(e)}")
            
            logging.error("generar_backup_bd_sanchezpharma: current_identity es None - Token no procesado correctamente")
            return jsonify({"code": 0, "message": "Usuario no autenticado"}), 401
        
        # Obtener rol_id del usuario desde la base de datos
        # Solo usuarios internos pueden acceder (clientes no tienen rol_id)
        conn = obtenerconexion_sanchezpharma()
        rol_id = None
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT rol_id FROM usuarios WHERE id = %s", (current_user.id,))
                usuario_data = cursor.fetchone()
                
                if usuario_data:
                    rol_id = usuario_data.get('rol_id')
                else:
                    # Si no está en usuarios, es un cliente - no tiene acceso
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo usuarios internos pueden generar backups."}), 403
                
                # Verificar que el usuario sea Ingeniero (rol_id = 6)
                if rol_id != 6:
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo el rol Ingeniero puede generar backups."}), 403

        # Crear directorio de backups si no existe
        backup_dir = '/tmp/backups_sanchezpharma'
        os.makedirs(backup_dir, exist_ok=True)

        # Generar nombre de archivo con timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"backup_bd_{timestamp}.sql"
        backup_path = os.path.join(backup_dir, backup_filename)

        # Configuración de la base de datos
        db_config = {
            'host': 'nxlsxx.mysql.pythonanywhere-services.com',
            'user': 'nxlsxx',
            'password': '77910396gG',
            'database': 'nxlsxx$PAF'
        }

        # Generar backup usando mysqldump
        try:
            # En PythonAnywhere, mysqldump está disponible
            cmd = [
                'mysqldump',
                f"--host={db_config['host']}",
                f"--user={db_config['user']}",
                f"--password={db_config['password']}",
                '--single-transaction',
                '--routines',
                '--triggers',
                db_config['database']
            ]
            
            with open(backup_path, 'w', encoding='utf-8') as f:
                result = subprocess.run(cmd, stdout=f, stderr=subprocess.PIPE, text=True)
                
            if result.returncode != 0:
                raise Exception(f"Error al generar backup: {result.stderr}")

            # Obtener tamaño del archivo
            file_size = os.path.getsize(backup_path)

            # Registrar en historial
            conn = obtenerconexion_sanchezpharma()
            with conn:
                with conn.cursor() as cursor:
                    cursor.execute("""
                        INSERT INTO backups_historial 
                        (tipo, nombre_archivo, ruta_archivo, tamano_bytes, usuario_id, estado, observaciones)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (
                        'bd',
                        backup_filename,
                        backup_path,
                        file_size,
                        current_user.id,
                        'completado',
                        f'Backup de base de datos generado exitosamente'
                    ))
                    backup_id = cursor.lastrowid
                conn.commit()

            logging.info(f"Backup de BD generado: {backup_path} por usuario {current_user.id}")

            return jsonify({
                "code": 1,
                "message": "Backup de base de datos generado correctamente",
                "data": {
                    "backup_id": backup_id,
                    "nombre_archivo": backup_filename,
                    "tamano_bytes": file_size,
                    "fecha": timestamp
                }
            })

        except Exception as e:
            logging.error(f"Error al generar backup de BD: {repr(e)}")
            return jsonify({"code": 0, "message": f"Error al generar backup: {str(e)}"})

    except Exception as e:
        logging.error(f"Error en generar_backup_bd_sanchezpharma: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# GENERAR BACKUP DE ARCHIVOS
@app.route('/generar_backup_archivos_sanchezpharma', methods=['POST'])
@jwt_required()
def generar_backup_archivos_sanchezpharma():
    try:
        # Obtener usuario del token
        current_user = getattr(g, 'current_identity', None)
        if not current_user:
            return jsonify({"code": 0, "message": "Usuario no autenticado"}), 401
        
        # Obtener rol_id del usuario desde la base de datos
        # Solo usuarios internos pueden acceder (clientes no tienen rol_id)
        conn = obtenerconexion_sanchezpharma()
        rol_id = None
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT rol_id FROM usuarios WHERE id = %s", (current_user.id,))
                usuario_data = cursor.fetchone()
                
                if usuario_data:
                    rol_id = usuario_data.get('rol_id')
                else:
                    # Si no está en usuarios, es un cliente - no tiene acceso
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo usuarios internos pueden generar backups."}), 403
                
                # Verificar que el usuario sea Ingeniero (rol_id = 6)
                if rol_id != 6:
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo el rol Ingeniero puede generar backups."}), 403

        # Crear directorio de backups si no existe
        backup_dir = '/tmp/backups_sanchezpharma'
        os.makedirs(backup_dir, exist_ok=True)

        # Generar nombre de archivo con timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"backup_archivos_{timestamp}.zip"
        backup_path = os.path.join(backup_dir, backup_filename)

        # Directorios a respaldar (ajustar según tu estructura)
        directorios_a_respaldar = [
            '/home/nxlsxx/sanchezpharmaapp',  # Ajustar según tu estructura
        ]

        # Crear archivo ZIP con los archivos
        try:
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for directorio in directorios_a_respaldar:
                    if os.path.exists(directorio):
                        for root, dirs, files in os.walk(directorio):
                            # Excluir directorios comunes que no necesitan backup
                            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'node_modules', '.venv', 'venv']]
                            
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.relpath(file_path, directorio)
                                try:
                                    zipf.write(file_path, arcname)
                                except Exception as e:
                                    logging.warning(f"No se pudo agregar {file_path} al backup: {e}")

            # Obtener tamaño del archivo
            file_size = os.path.getsize(backup_path)

            # Registrar en historial
            conn = obtenerconexion_sanchezpharma()
            with conn:
                with conn.cursor() as cursor:
                    cursor.execute("""
                        INSERT INTO backups_historial 
                        (tipo, nombre_archivo, ruta_archivo, tamano_bytes, usuario_id, estado, observaciones)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (
                        'archivos',
                        backup_filename,
                        backup_path,
                        file_size,
                        current_user.id,
                        'completado',
                        f'Backup de archivos generado exitosamente'
                    ))
                    backup_id = cursor.lastrowid
                conn.commit()

            logging.info(f"Backup de archivos generado: {backup_path} por usuario {current_user.id}")

            return jsonify({
                "code": 1,
                "message": "Backup de archivos generado correctamente",
                "data": {
                    "backup_id": backup_id,
                    "nombre_archivo": backup_filename,
                    "tamano_bytes": file_size,
                    "fecha": timestamp
                }
            })

        except Exception as e:
            logging.error(f"Error al generar backup de archivos: {repr(e)}")
            return jsonify({"code": 0, "message": f"Error al generar backup: {str(e)}"})

    except Exception as e:
        logging.error(f"Error en generar_backup_archivos_sanchezpharma: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# GENERAR BACKUP COMPLETO (BD + ARCHIVOS)
@app.route('/generar_backup_completo_sanchezpharma', methods=['POST'])
@jwt_required()
def generar_backup_completo_sanchezpharma():
    try:
        # Obtener usuario del token
        current_user = getattr(g, 'current_identity', None)
        if not current_user:
            return jsonify({"code": 0, "message": "Usuario no autenticado"}), 401
        
        # Obtener rol_id del usuario desde la base de datos
        # Solo usuarios internos pueden acceder (clientes no tienen rol_id)
        conn = obtenerconexion_sanchezpharma()
        rol_id = None
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT rol_id FROM usuarios WHERE id = %s", (current_user.id,))
                usuario_data = cursor.fetchone()
                
                if usuario_data:
                    rol_id = usuario_data.get('rol_id')
                else:
                    # Si no está en usuarios, es un cliente - no tiene acceso
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo usuarios internos pueden generar backups."}), 403
                
                # Verificar que el usuario sea Ingeniero (rol_id = 6)
                if rol_id != 6:
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo el rol Ingeniero puede generar backups."}), 403

        # Generar ambos backups
        # Primero BD - extraer la lógica en lugar de llamar la función directamente
        backup_bd_data = None
        backup_bd_error = None
        try:
            # Crear directorio de backups si no existe
            backup_dir = '/tmp/backups_sanchezpharma'
            os.makedirs(backup_dir, exist_ok=True)

            # Generar nombre de archivo con timestamp para BD
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_bd_filename = f"backup_bd_{timestamp}.sql"
            backup_bd_path = os.path.join(backup_dir, backup_bd_filename)

            # Configuración de la base de datos
            db_config = {
                'host': 'nxlsxx.mysql.pythonanywhere-services.com',
                'user': 'nxlsxx',
                'password': '77910396gG',
                'database': 'nxlsxx$PAF'
            }

            # Generar backup de BD usando mysqldump
            cmd = [
                'mysqldump',
                f"--host={db_config['host']}",
                f"--user={db_config['user']}",
                f"--password={db_config['password']}",
                '--single-transaction',
                '--routines',
                '--triggers',
                db_config['database']
            ]
            
            with open(backup_bd_path, 'w', encoding='utf-8') as f:
                result = subprocess.run(cmd, stdout=f, stderr=subprocess.PIPE, text=True)
                
            if result.returncode != 0:
                backup_bd_error = f"Error al generar backup de BD: {result.stderr}"
            else:
                # Obtener tamaño del archivo
                file_size_bd = os.path.getsize(backup_bd_path)

                # Registrar en historial
                conn = obtenerconexion_sanchezpharma()
                with conn:
                    with conn.cursor() as cursor:
                        cursor.execute("""
                            INSERT INTO backups_historial 
                            (tipo, nombre_archivo, ruta_archivo, tamano_bytes, usuario_id, estado, observaciones)
                            VALUES (%s, %s, %s, %s, %s, %s, %s)
                        """, (
                            'bd',
                            backup_bd_filename,
                            backup_bd_path,
                            file_size_bd,
                            current_user.id,
                            'completado',
                            f'Backup de base de datos generado exitosamente'
                        ))
                        backup_bd_id = cursor.lastrowid
                    conn.commit()

                backup_bd_data = {
                    "backup_id": backup_bd_id,
                    "nombre_archivo": backup_bd_filename,
                    "tamano_bytes": file_size_bd,
                    "fecha": timestamp
                }
                logging.info(f"Backup de BD generado: {backup_bd_path} por usuario {current_user.id}")
        except Exception as e:
            backup_bd_error = f"Error al generar backup de BD: {str(e)}"
            logging.error(f"Error al generar backup de BD: {repr(e)}")

        # Luego archivos - extraer la lógica en lugar de llamar la función directamente
        backup_archivos_data = None
        backup_archivos_error = None
        try:
            # Crear directorio de backups si no existe
            backup_dir = '/tmp/backups_sanchezpharma'
            os.makedirs(backup_dir, exist_ok=True)

            # Generar nombre de archivo con timestamp para archivos
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_archivos_filename = f"backup_archivos_{timestamp}.zip"
            backup_archivos_path = os.path.join(backup_dir, backup_archivos_filename)

            # Directorios a respaldar (ajustar según tu estructura)
            directorios_a_respaldar = [
                '/home/nxlsxx/sanchezpharmaapp',  # Ajustar según tu estructura
            ]

            # Crear archivo ZIP con los archivos
            with zipfile.ZipFile(backup_archivos_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for directorio in directorios_a_respaldar:
                    if os.path.exists(directorio):
                        for root, dirs, files in os.walk(directorio):
                            # Excluir directorios comunes que no necesitan backup
                            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'node_modules', '.venv', 'venv']]
                            
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.relpath(file_path, directorio)
                                try:
                                    zipf.write(file_path, arcname)
                                except Exception as e:
                                    logging.warning(f"No se pudo agregar {file_path} al backup: {e}")

            # Obtener tamaño del archivo
            file_size_archivos = os.path.getsize(backup_archivos_path)

            # Registrar en historial
            conn = obtenerconexion_sanchezpharma()
            with conn:
                with conn.cursor() as cursor:
                    cursor.execute("""
                        INSERT INTO backups_historial 
                        (tipo, nombre_archivo, ruta_archivo, tamano_bytes, usuario_id, estado, observaciones)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (
                        'archivos',
                        backup_archivos_filename,
                        backup_archivos_path,
                        file_size_archivos,
                        current_user.id,
                        'completado',
                        f'Backup de archivos generado exitosamente'
                    ))
                    backup_archivos_id = cursor.lastrowid
                conn.commit()

            backup_archivos_data = {
                "backup_id": backup_archivos_id,
                "nombre_archivo": backup_archivos_filename,
                "tamano_bytes": file_size_archivos,
                "fecha": timestamp
            }
            logging.info(f"Backup de archivos generado: {backup_archivos_path} por usuario {current_user.id}")
        except Exception as e:
            backup_archivos_error = f"Error al generar backup de archivos: {str(e)}"
            logging.error(f"Error al generar backup de archivos: {repr(e)}")

        # Verificar resultados
        if backup_bd_data and backup_archivos_data:
            # Ambos backups fueron exitosos
            return jsonify({
                "code": 1,
                "message": "Backup completo generado correctamente",
                "data": {
                    "backup_bd": backup_bd_data,
                    "backup_archivos": backup_archivos_data
                }
            })
        elif backup_bd_data:
            # Solo BD fue exitoso
            return jsonify({
                "code": 0,
                "message": f"Backup de BD generado, pero error en archivos: {backup_archivos_error}",
                "data": {
                    "backup_bd": backup_bd_data
                }
            })
        elif backup_archivos_data:
            # Solo archivos fue exitoso
            return jsonify({
                "code": 0,
                "message": f"Backup de archivos generado, pero error en BD: {backup_bd_error}",
                "data": {
                    "backup_archivos": backup_archivos_data
                }
            })
        else:
            # Ambos fallaron
            return jsonify({
                "code": 0,
                "message": f"Error al generar backup completo. BD: {backup_bd_error}, Archivos: {backup_archivos_error}"
            })

    except Exception as e:
        logging.error(f"Error en generar_backup_completo_sanchezpharma: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)})


# DESCARGAR BACKUP
@app.route('/descargar_backup_sanchezpharma/<int:backup_id>')
@jwt_required()
def descargar_backup_sanchezpharma(backup_id):
    try:
        # Obtener usuario del token
        current_user = getattr(g, 'current_identity', None)
        if not current_user:
            return jsonify({"code": 0, "message": "Usuario no autenticado"}), 401
        
        # Obtener rol_id del usuario desde la base de datos
        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT rol_id FROM usuarios WHERE id = %s", (current_user.id,))
                usuario_data = cursor.fetchone()
                
                if not usuario_data:
                    return jsonify({"code": 0, "message": "Usuario no encontrado"}), 404
                
                rol_id = usuario_data.get('rol_id')
                
                # Verificar que el usuario sea Ingeniero (rol_id = 6)
                if rol_id != 6:
                    return jsonify({"code": 0, "message": "Acceso denegado. Solo el rol Ingeniero puede descargar backups."}), 403

        conn = obtenerconexion_sanchezpharma()
        with conn:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT * FROM backups_historial WHERE id = %s
                """, (backup_id,))
                backup = cursor.fetchone()

                if not backup:
                    return jsonify({"code": 0, "message": "Backup no encontrado"}), 404

                ruta_archivo = backup['ruta_archivo']
                
                if not os.path.exists(ruta_archivo):
                    return jsonify({"code": 0, "message": "El archivo de backup no existe en el servidor"}), 404

                # Enviar archivo para descarga
                return send_file(
                    ruta_archivo,
                    as_attachment=True,
                    download_name=backup['nombre_archivo'],
                    mimetype='application/octet-stream'
                )

    except Exception as e:
        logging.error(f"Error al descargar backup: {repr(e)}")
        return jsonify({"code": 0, "message": repr(e)}), 500


# ---------------------------------------------------
# VERIFICACIÓN DE VERSIÓN DE LA APP
# ---------------------------------------------------
@app.route('/api_version_check', methods=['GET'])
def api_version_check():
    """
    Endpoint para verificar si hay actualizaciones disponibles de la app.
    No requiere autenticación para que funcione incluso si el token expiró.
    """
    try:
        # Versión actual de la app en producción
        # Actualiza estos valores cuando subas una nueva versión
        CURRENT_VERSION = "1.0.0"
        MINIMUM_VERSION = "1.0.0"  # Versión mínima requerida (forzada)
        LATEST_VERSION = "1.0.1"   # Última versión disponible
        
        # URL donde está alojado el APK (ajusta según tu servidor)
        # Ejemplo: https://tudominio.com/downloads/app-v1.0.1.apk
        APK_BASE_URL = "https://nxlsxx.pythonanywhere.com/downloads"
        APK_FILENAME = f"sanchezpharmaapp-v{LATEST_VERSION}.apk"
        APK_URL = f"{APK_BASE_URL}/{APK_FILENAME}"
        
        # Tamaño del APK en bytes (ajusta según el tamaño real)
        # Puedes calcularlo automáticamente si el archivo existe
        APK_SIZE = 25000000  # 25 MB aproximado
        
        # Obtener versión del cliente desde query params (opcional)
        client_version = request.args.get('version', CURRENT_VERSION)
        
        # Comparar versiones (asumiendo formato semántico: major.minor.patch)
        def compare_versions(v1, v2):
            """Compara dos versiones. Retorna: -1 si v1 < v2, 0 si igual, 1 si v1 > v2"""
            v1_parts = [int(x) for x in v1.split('.')]
            v2_parts = [int(x) for x in v2.split('.')]
            
            # Asegurar que ambas tengan la misma longitud
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            for i in range(max_len):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            return 0
        
        # Verificar si necesita actualización
        needs_update = compare_versions(client_version, LATEST_VERSION) < 0
        force_update = compare_versions(client_version, MINIMUM_VERSION) < 0
        
        return jsonify({
            "code": 1,
            "data": {
                "current_version": CURRENT_VERSION,
                "minimum_version": MINIMUM_VERSION,
                "latest_version": LATEST_VERSION,
                "client_version": client_version,
                "needs_update": needs_update,
                "force_update": force_update,
                "apk_url": APK_URL,
                "apk_size": APK_SIZE,
                "update_message": "Nueva versión disponible con mejoras y correcciones" if needs_update else "Ya tienes la última versión",
                "release_notes": "• Mejoras en rendimiento\n• Corrección de errores\n• Nuevas funcionalidades"
            },
            "message": "Información de versión obtenida correctamente"
        })
        
    except Exception as e:
        logging.error(f"Error al verificar versión: {repr(e)}")
        return jsonify({
            "code": 0,
            "data": {},
            "message": f"Error al verificar versión: {str(e)}"
        }), 500


# ---------------------------------------------------
# FIN
# ---------------------------------------------------
if __name__ == "__main__":
    app.run()
    